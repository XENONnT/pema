
Pema datastructure
===========================================================

This page is an autogenerated reference for all the plugins in straxen's
`xenonnt_online` context. 

Colors indicate data kinds. To load tables with different data kinds,
you currently need more than one `get_df` (or `get_array`) commands.


match_acceptance_extended
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `AcceptanceExtended <https://github.com/XENONnT/pema/blob/master/pema/match_plugins.py>`_

Data kind: truth

Merge the matched acceptance to the extended truth


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>endtime</td>          <td>int64</td>          <td>Exclusive end time since unix epoch [ns]</td>        </tr>        <tr>          <td>is_found</td>          <td>bool</td>          <td>Is the peak tagged "found" in the reconstructed data</td>        </tr>        <tr>          <td>acceptance_fraction</td>          <td>float64</td>          <td>Acceptance of the peak can be negative for penalized reconstruction</td>        </tr>        <tr>          <td>rec_bias</td>          <td>float64</td>          <td>Reconstruction bias 1 is perfect, 0.1 means incorrect</td>        </tr>        <tr>          <td>event_number</td>          <td>int32</td>          <td>Waveform simulator event number.</td>        </tr>        <tr>          <td>type</td>          <td>int8</td>          <td>Quanta type (S1 photons or S2 electrons)</td>        </tr>        <tr>          <td>x</td>          <td>float32</td>          <td>X position of the cluster[cm]</td>        </tr>        <tr>          <td>y</td>          <td>float32</td>          <td>Y position of the cluster[cm]</td>        </tr>        <tr>          <td>z</td>          <td>float32</td>          <td>Z position of the cluster[cm]</td>        </tr>        <tr>          <td>amp</td>          <td>int32</td>          <td>Number of quanta</td>        </tr>        <tr>          <td>recoil</td>          <td>int8</td>          <td>Recoil type of interaction.</td>        </tr>        <tr>          <td>e_dep</td>          <td>float32</td>          <td>Energy deposit of interaction</td>        </tr>        <tr>          <td>g4id</td>          <td>int32</td>          <td>Eventid like in geant4 output rootfile</td>        </tr>        <tr>          <td>vol_id</td>          <td>int32</td>          <td>Volume id giving the detector subvolume</td>        </tr>        <tr>          <td>n_electron</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>n_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>n_photon_bottom</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_first_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_last_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_mean_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_sigma_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_first_electron</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_last_electron</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_mean_electron</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_sigma_electron</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>id</td>          <td>int64</td>          <td>Id of element in truth</td>        </tr>        <tr>          <td>outcome</td>          <td>&lt;U32</td>          <td>Outcome of matching to peaks</td>        </tr>        <tr>          <td>matched_to</td>          <td>int64</td>          <td>Id of matching element in peaks</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="579pt" height="764pt"
     viewBox="0.00 0.00 579.46 764.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 760)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-760 575.4563,-760 575.4563,4 -4,4"/>
    <!-- match_acceptance_extended -->
    <g id="node1" class="node">
    <title>match_acceptance_extended</title>
    <g id="a_node1"><a xlink:href="#match-acceptance-extended" xlink:title="match_acceptance_extended">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="421.9627" cy="-738" rx="145.6742" ry="18"/>
    <text text-anchor="middle" x="421.9627" y="-734.3" font-family="Times,serif" font-size="14.00" fill="#000000">match_acceptance_extended</text>
    </a>
    </g>
    </g>
    <!-- match_acceptance -->
    <g id="node2" class="node">
    <title>match_acceptance</title>
    <g id="a_node2"><a xlink:href="#match-acceptance" xlink:title="match_acceptance">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="290.9627" cy="-666" rx="98.2828" ry="18"/>
    <text text-anchor="middle" x="290.9627" y="-662.3" font-family="Times,serif" font-size="14.00" fill="#000000">match_acceptance</text>
    </a>
    </g>
    </g>
    <!-- match_acceptance_extended&#45;&gt;match_acceptance -->
    <g id="edge1" class="edge">
    <title>match_acceptance_extended&#45;&gt;match_acceptance</title>
    <path fill="none" stroke="#000000" d="M389.9165,-720.3868C372.2107,-710.6554 350.0467,-698.4737 331.1857,-688.1073"/>
    <polygon fill="#000000" stroke="#000000" points="332.6754,-684.9323 322.226,-683.1829 329.3037,-691.0668 332.6754,-684.9323"/>
    </g>
    <!-- truth -->
    <g id="node3" class="node">
    <title>truth</title>
    <g id="a_node3"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="332.9627" cy="-450" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="332.9627" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    <!-- match_acceptance_extended&#45;&gt;truth -->
    <g id="edge2" class="edge">
    <title>match_acceptance_extended&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M422.8077,-719.7069C423.9159,-678.5173 422.1615,-576.4458 382.9627,-504 376.6925,-492.4117 367.3603,-481.3969 358.4505,-472.374"/>
    <polygon fill="#000000" stroke="#000000" points="360.76,-469.7383 351.1421,-465.2944 355.8896,-474.7661 360.76,-469.7383"/>
    </g>
    <!-- truth_matched -->
    <g id="node4" class="node">
    <title>truth_matched</title>
    <g id="a_node4"><a xlink:href="#truth-matched" xlink:title="truth_matched">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="278.9627" cy="-522" rx="79.8859" ry="18"/>
    <text text-anchor="middle" x="278.9627" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth_matched</text>
    </a>
    </g>
    </g>
    <!-- match_acceptance_extended&#45;&gt;truth_matched -->
    <g id="edge3" class="edge">
    <title>match_acceptance_extended&#45;&gt;truth_matched</title>
    <path fill="none" stroke="#000000" d="M419.7924,-719.7624C416.9438,-700.8429 410.7222,-670.8797 397.9627,-648 375.1541,-607.1007 336.0951,-569.3604 308.975,-546.0549"/>
    <polygon fill="#000000" stroke="#000000" points="311.2171,-543.3672 301.3199,-539.5861 306.699,-548.7139 311.2171,-543.3672"/>
    </g>
    <!-- match_acceptance&#45;&gt;truth -->
    <g id="edge4" class="edge">
    <title>match_acceptance&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M306.5355,-647.9149C325.3661,-624.7338 356.0197,-582.4463 367.9627,-540 372.2963,-524.598 372.5001,-519.3431 367.9627,-504 364.9211,-493.7152 359.2389,-483.5503 353.3242,-474.8616"/>
    <polygon fill="#000000" stroke="#000000" points="356.123,-472.7591 347.4211,-466.7152 350.4547,-476.8665 356.123,-472.7591"/>
    </g>
    <!-- match_acceptance&#45;&gt;truth_matched -->
    <g id="edge5" class="edge">
    <title>match_acceptance&#45;&gt;truth_matched</title>
    <path fill="none" stroke="#000000" d="M289.4429,-647.7623C287.3961,-623.201 283.7333,-579.2474 281.3255,-550.3541"/>
    <polygon fill="#000000" stroke="#000000" points="284.7886,-549.7644 280.4701,-540.0896 277.8128,-550.3458 284.7886,-549.7644"/>
    </g>
    <!-- peaks_extended -->
    <g id="node5" class="node">
    <title>peaks_extended</title>
    <g id="a_node5"><a xlink:href="#peaks-extended" xlink:title="peaks_extended">
    <ellipse fill="#98fb98" stroke="#000000" cx="97.9627" cy="-594" rx="85.5853" ry="18"/>
    <text text-anchor="middle" x="97.9627" y="-590.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks_extended</text>
    </a>
    </g>
    </g>
    <!-- match_acceptance&#45;&gt;peaks_extended -->
    <g id="edge6" class="edge">
    <title>match_acceptance&#45;&gt;peaks_extended</title>
    <path fill="none" stroke="#000000" d="M247.6497,-649.8418C218.6674,-639.0297 180.3767,-624.7451 149.7783,-613.3302"/>
    <polygon fill="#000000" stroke="#000000" points="150.7283,-609.949 140.1356,-609.7329 148.2816,-616.5075 150.7283,-609.949"/>
    </g>
    <!-- truth_matched&#45;&gt;truth -->
    <g id="edge7" class="edge">
    <title>truth_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M292.311,-504.2022C298.8815,-495.4416 306.9157,-484.7293 314.1015,-475.1482"/>
    <polygon fill="#000000" stroke="#000000" points="316.9397,-477.1973 320.1398,-467.0972 311.3397,-472.9972 316.9397,-477.1973"/>
    </g>
    <!-- peak_basics -->
    <g id="node7" class="node">
    <title>peak_basics</title>
    <g id="a_node7"><a xlink:href="#peak-basics" xlink:title="peak_basics">
    <ellipse fill="#98fb98" stroke="#000000" cx="97.9627" cy="-450" rx="67.6881" ry="18"/>
    <text text-anchor="middle" x="97.9627" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">peak_basics</text>
    </a>
    </g>
    </g>
    <!-- truth_matched&#45;&gt;peak_basics -->
    <g id="edge8" class="edge">
    <title>truth_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M239.2415,-506.1993C211.5672,-495.1907 174.5264,-480.4563 145.3154,-468.8364"/>
    <polygon fill="#000000" stroke="#000000" points="146.3196,-465.4692 135.734,-465.0251 143.7322,-471.9735 146.3196,-465.4692"/>
    </g>
    <!-- peaks_extended&#45;&gt;peak_basics -->
    <g id="edge23" class="edge">
    <title>peaks_extended&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M52.2011,-578.5932C34.4951,-570.1357 16.0855,-557.6794 5.9627,-540 -1.9876,-526.115 -1.9876,-517.885 5.9627,-504 14.8863,-488.415 30.2496,-476.8889 45.8937,-468.5829"/>
    <polygon fill="#000000" stroke="#000000" points="47.6628,-471.6133 55.0907,-464.0583 44.5727,-465.3323 47.6628,-471.6133"/>
    </g>
    <!-- peaks_matched -->
    <g id="node8" class="node">
    <title>peaks_matched</title>
    <g id="a_node8"><a xlink:href="#peaks-matched" xlink:title="peaks_matched">
    <ellipse fill="#98fb98" stroke="#000000" cx="97.9627" cy="-522" rx="83.3857" ry="18"/>
    <text text-anchor="middle" x="97.9627" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks_matched</text>
    </a>
    </g>
    </g>
    <!-- peaks_extended&#45;&gt;peaks_matched -->
    <g id="edge24" class="edge">
    <title>peaks_extended&#45;&gt;peaks_matched</title>
    <path fill="none" stroke="#000000" d="M97.9627,-575.8314C97.9627,-568.131 97.9627,-558.9743 97.9627,-550.4166"/>
    <polygon fill="#000000" stroke="#000000" points="101.4628,-550.4132 97.9627,-540.4133 94.4628,-550.4133 101.4628,-550.4132"/>
    </g>
    <!-- raw_records -->
    <g id="node6" class="node">
    <title>raw_records</title>
    <g id="a_node6"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="339.9627" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="339.9627" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- peaks -->
    <g id="node9" class="node">
    <title>peaks</title>
    <g id="a_node9"><a xlink:href="#peaks" xlink:title="peaks">
    <ellipse fill="#98fb98" stroke="#000000" cx="97.9627" cy="-378" rx="38.1938" ry="18"/>
    <text text-anchor="middle" x="97.9627" y="-374.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks</text>
    </a>
    </g>
    </g>
    <!-- peak_basics&#45;&gt;peaks -->
    <g id="edge11" class="edge">
    <title>peak_basics&#45;&gt;peaks</title>
    <path fill="none" stroke="#000000" d="M97.9627,-431.8314C97.9627,-424.131 97.9627,-414.9743 97.9627,-406.4166"/>
    <polygon fill="#000000" stroke="#000000" points="101.4628,-406.4132 97.9627,-396.4133 94.4628,-406.4133 101.4628,-406.4132"/>
    </g>
    <!-- peaks_matched&#45;&gt;truth -->
    <g id="edge9" class="edge">
    <title>peaks_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M146.0855,-507.256C189.5362,-493.9434 252.7067,-474.5891 293.3171,-462.1467"/>
    <polygon fill="#000000" stroke="#000000" points="294.5939,-465.4162 303.1299,-459.1403 292.5433,-458.7233 294.5939,-465.4162"/>
    </g>
    <!-- peaks_matched&#45;&gt;peak_basics -->
    <g id="edge10" class="edge">
    <title>peaks_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M97.9627,-503.8314C97.9627,-496.131 97.9627,-486.9743 97.9627,-478.4166"/>
    <polygon fill="#000000" stroke="#000000" points="101.4628,-478.4132 97.9627,-468.4133 94.4628,-478.4133 101.4628,-478.4132"/>
    </g>
    <!-- peaklets -->
    <g id="node10" class="node">
    <title>peaklets</title>
    <g id="a_node10"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="145.9627" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="145.9627" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklets -->
    <g id="edge12" class="edge">
    <title>peaks&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M80.0317,-361.5318C49.3136,-331.279 -7.1062,-265.4292 24.9627,-216 39.6634,-193.3411 66.3326,-180.1078 90.8991,-172.4205"/>
    <polygon fill="#000000" stroke="#000000" points="91.8981,-175.7751 100.5382,-169.6433 89.9601,-169.0488 91.8981,-175.7751"/>
    </g>
    <!-- peaklet_classification -->
    <g id="node11" class="node">
    <title>peaklet_classification</title>
    <g id="a_node11"><a xlink:href="#peaklet-classification" xlink:title="peaklet_classification">
    <ellipse fill="#d9ff66" stroke="#000000" cx="145.9627" cy="-234" rx="111.5806" ry="18"/>
    <text text-anchor="middle" x="145.9627" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklet_classification</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklet_classification -->
    <g id="edge13" class="edge">
    <title>peaks&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M100.2236,-359.9931C102.8965,-341.5194 108.1358,-312.148 116.9627,-288 120.2541,-278.9955 124.8206,-269.6408 129.3571,-261.2976"/>
    <polygon fill="#000000" stroke="#000000" points="132.5236,-262.8082 134.3965,-252.3802 126.4294,-259.3642 132.5236,-262.8082"/>
    </g>
    <!-- merged_s2s -->
    <g id="node12" class="node">
    <title>merged_s2s</title>
    <g id="a_node12"><a xlink:href="#merged-s2s" xlink:title="merged_s2s">
    <ellipse fill="#ccffcc" stroke="#000000" cx="192.9627" cy="-306" rx="66.8882" ry="18"/>
    <text text-anchor="middle" x="192.9627" y="-302.3" font-family="Times,serif" font-size="14.00" fill="#000000">merged_s2s</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;merged_s2s -->
    <g id="edge14" class="edge">
    <title>peaks&#45;&gt;merged_s2s</title>
    <path fill="none" stroke="#000000" d="M118.5763,-362.3771C131.3492,-352.6965 147.9898,-340.0847 162.2923,-329.2449"/>
    <polygon fill="#000000" stroke="#000000" points="164.5407,-331.9326 170.3963,-323.1029 160.3125,-326.3538 164.5407,-331.9326"/>
    </g>
    <!-- records -->
    <g id="node13" class="node">
    <title>records</title>
    <g id="a_node13"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="205.9627" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="205.9627" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge15" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M160.487,-144.5708C167.8569,-135.7269 176.9428,-124.8239 185.0506,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="187.859,-117.1916 191.5721,-107.2687 182.4814,-112.7103 187.859,-117.1916"/>
    </g>
    <!-- peaklet_classification&#45;&gt;peaklets -->
    <g id="edge20" class="edge">
    <title>peaklet_classification&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M145.9627,-215.8314C145.9627,-208.131 145.9627,-198.9743 145.9627,-190.4166"/>
    <polygon fill="#000000" stroke="#000000" points="149.4628,-190.4132 145.9627,-180.4133 142.4628,-190.4133 149.4628,-190.4132"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklets -->
    <g id="edge21" class="edge">
    <title>merged_s2s&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M226.8776,-290.4273C242.0736,-281.5104 258.4601,-268.7303 266.9627,-252 274.2117,-237.7363 275.671,-229.4226 266.9627,-216 258.2917,-202.635 223.5822,-187.9245 193.549,-177.2369"/>
    <polygon fill="#000000" stroke="#000000" points="194.5961,-173.8954 184.0012,-173.915 192.2958,-180.5067 194.5961,-173.8954"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklet_classification -->
    <g id="edge22" class="edge">
    <title>merged_s2s&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M181.3447,-288.2022C175.9063,-279.871 169.3157,-269.7748 163.3037,-260.565"/>
    <polygon fill="#000000" stroke="#000000" points="166.1706,-258.5537 157.7735,-252.0931 160.3089,-262.3801 166.1706,-258.5537"/>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge17" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M233.0796,-75.4297C252.4851,-65.0029 278.9088,-50.8051 300.6277,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="302.4613,-42.1233 309.6136,-34.307 299.148,-35.9571 302.4613,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node14" class="node">
    <title>lone_hits</title>
    <g id="a_node14"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="266.9627" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="266.9627" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge16" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M252.1963,-144.5708C244.7035,-135.7269 235.4663,-124.8239 227.2233,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="229.7278,-112.6361 220.5931,-107.2687 224.3868,-117.161 229.7278,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node15" class="node">
    <title>veto_regions</title>
    <g id="a_node15"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="339.9627" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="339.9627" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge18" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M339.9627,-71.8314C339.9627,-64.131 339.9627,-54.9743 339.9627,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="343.4628,-46.4132 339.9627,-36.4133 336.4628,-46.4133 343.4628,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node16" class="node">
    <title>pulse_counts</title>
    <g id="a_node16"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="499.9627" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="499.9627" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge19" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M464.85,-74.1993C441.1135,-63.5179 409.582,-49.3287 384.1413,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="385.2736,-34.5519 374.718,-33.6399 382.401,-40.9353 385.2736,-34.5519"/>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaks,)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>dpe_fraction</td>          <td>0.219</td>          <td>&lt;OMITTED&gt;</td>          <td>(match_acceptance,)</td>          <td>Probability of double photon emission (conversion between n_photon in truth and area in peaks)</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>min_s2_bias_rec</td>          <td>0.65</td>          <td>&lt;OMITTED&gt;</td>          <td>(match_acceptance,)</td>          <td>If the</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>253</td>          <td>253</td>          <td>(peak_basics,)</td>          <td>Number of top PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>penalty_s2_by</td>          <td>((misid_as_s1, -1.0), (split_and_misid, -1.0))</td>          <td>&lt;OMITTED&gt;</td>          <td>(match_acceptance,)</td>          <td>Add a penalty to the acceptance fraction if the peak has the outcome. Should be tuple of tuples where each tuple should have the format of (outcome, penalty_factor)</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>s1_max_rise_time</td>          <td>60</td>          <td>100</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &lt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_max_rise_time_post100</td>          <td>150</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &gt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_min_coincidence</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum tight coincidence necessary to make an S1</td>        </tr>        <tr>          <td>s2_merge_max_area</td>          <td>5000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Merge peaklet cluster only if area &lt; this [PE]</td>        </tr>        <tr>          <td>s2_merge_max_duration</td>          <td>15000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Do not merge peaklets at all if the result would be a peak longer than this [ns]</td>        </tr>        <tr>          <td>s2_merge_max_gap</td>          <td>3500</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Maximum separation between peaklets to allow merging [ns]</td>        </tr>        <tr>          <td>s2_min_pmts</td>          <td>4</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum number of PMTs contributing to an S2</td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



match_acceptance
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `AcceptanceComputer <https://github.com/XENONnT/pema/blob/master/pema/match_plugins.py>`_

Data kind: truth


    Compute the acceptance of the matched peaks. This is done on the
        basis of arbitrary settings to allow better to disentangle
        possible scenarios that might be undesirable (like splitting
        an S2 into small S1 signals that could affect event
        reconstruction).
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>endtime</td>          <td>int64</td>          <td>Exclusive end time since unix epoch [ns]</td>        </tr>        <tr>          <td>is_found</td>          <td>bool</td>          <td>Is the peak tagged "found" in the reconstructed data</td>        </tr>        <tr>          <td>acceptance_fraction</td>          <td>float64</td>          <td>Acceptance of the peak can be negative for penalized reconstruction</td>        </tr>        <tr>          <td>rec_bias</td>          <td>float64</td>          <td>Reconstruction bias 1 is perfect, 0.1 means incorrect</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="761pt" height="692pt"
     viewBox="0.00 0.00 760.63 692.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 688)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-688 756.6349,-688 756.6349,4 -4,4"/>
    <!-- match_acceptance -->
    <g id="node1" class="node">
    <title>match_acceptance</title>
    <g id="a_node1"><a xlink:href="#match-acceptance" xlink:title="match_acceptance">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="98.1413" cy="-666" rx="98.2828" ry="18"/>
    <text text-anchor="middle" x="98.1413" y="-662.3" font-family="Times,serif" font-size="14.00" fill="#000000">match_acceptance</text>
    </a>
    </g>
    </g>
    <!-- truth -->
    <g id="node2" class="node">
    <title>truth</title>
    <g id="a_node2"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="98.1413" cy="-450" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="98.1413" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    <!-- match_acceptance&#45;&gt;truth -->
    <g id="edge1" class="edge">
    <title>match_acceptance&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M79.8059,-647.988C58.0561,-625.2045 23.0024,-583.6488 9.1413,-540 4.2987,-524.7504 1.2925,-517.9426 9.1413,-504 19.911,-484.8685 40.4998,-471.7344 59.164,-463.2138"/>
    <polygon fill="#000000" stroke="#000000" points="60.5707,-466.419 68.4024,-459.2835 57.8304,-459.9777 60.5707,-466.419"/>
    </g>
    <!-- truth_matched -->
    <g id="node3" class="node">
    <title>truth_matched</title>
    <g id="a_node3"><a xlink:href="#truth-matched" xlink:title="truth_matched">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="98.1413" cy="-522" rx="79.8859" ry="18"/>
    <text text-anchor="middle" x="98.1413" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth_matched</text>
    </a>
    </g>
    </g>
    <!-- match_acceptance&#45;&gt;truth_matched -->
    <g id="edge2" class="edge">
    <title>match_acceptance&#45;&gt;truth_matched</title>
    <path fill="none" stroke="#000000" d="M98.1413,-647.7623C98.1413,-623.201 98.1413,-579.2474 98.1413,-550.3541"/>
    <polygon fill="#000000" stroke="#000000" points="101.6414,-550.0896 98.1413,-540.0896 94.6414,-550.0897 101.6414,-550.0896"/>
    </g>
    <!-- peaks_extended -->
    <g id="node4" class="node">
    <title>peaks_extended</title>
    <g id="a_node4"><a xlink:href="#peaks-extended" xlink:title="peaks_extended">
    <ellipse fill="#98fb98" stroke="#000000" cx="279.1413" cy="-594" rx="85.5853" ry="18"/>
    <text text-anchor="middle" x="279.1413" y="-590.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks_extended</text>
    </a>
    </g>
    </g>
    <!-- match_acceptance&#45;&gt;peaks_extended -->
    <g id="edge3" class="edge">
    <title>match_acceptance&#45;&gt;peaks_extended</title>
    <path fill="none" stroke="#000000" d="M139.6663,-649.4817C166.4845,-638.8137 201.5135,-624.8796 229.7574,-613.6444"/>
    <polygon fill="#000000" stroke="#000000" points="231.0559,-616.8947 239.054,-609.9463 228.4685,-610.3904 231.0559,-616.8947"/>
    </g>
    <!-- truth_matched&#45;&gt;truth -->
    <g id="edge4" class="edge">
    <title>truth_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M98.1413,-503.8314C98.1413,-496.131 98.1413,-486.9743 98.1413,-478.4166"/>
    <polygon fill="#000000" stroke="#000000" points="101.6414,-478.4132 98.1413,-468.4133 94.6414,-478.4133 101.6414,-478.4132"/>
    </g>
    <!-- peak_basics -->
    <g id="node6" class="node">
    <title>peak_basics</title>
    <g id="a_node6"><a xlink:href="#peak-basics" xlink:title="peak_basics">
    <ellipse fill="#98fb98" stroke="#000000" cx="279.1413" cy="-450" rx="67.6881" ry="18"/>
    <text text-anchor="middle" x="279.1413" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">peak_basics</text>
    </a>
    </g>
    </g>
    <!-- truth_matched&#45;&gt;peak_basics -->
    <g id="edge5" class="edge">
    <title>truth_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M137.8625,-506.1993C165.5368,-495.1907 202.5775,-480.4563 231.7886,-468.8364"/>
    <polygon fill="#000000" stroke="#000000" points="233.3718,-471.9735 241.3699,-465.0251 230.7844,-465.4692 233.3718,-471.9735"/>
    </g>
    <!-- peaks_extended&#45;&gt;peak_basics -->
    <g id="edge20" class="edge">
    <title>peaks_extended&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M324.9029,-578.5932C342.6089,-570.1357 361.0185,-557.6794 371.1413,-540 379.0915,-526.115 379.0915,-517.885 371.1413,-504 362.2177,-488.415 346.8544,-476.8889 331.2102,-468.5829"/>
    <polygon fill="#000000" stroke="#000000" points="332.5313,-465.3323 322.0133,-464.0583 329.4411,-471.6133 332.5313,-465.3323"/>
    </g>
    <!-- peaks_matched -->
    <g id="node7" class="node">
    <title>peaks_matched</title>
    <g id="a_node7"><a xlink:href="#peaks-matched" xlink:title="peaks_matched">
    <ellipse fill="#98fb98" stroke="#000000" cx="279.1413" cy="-522" rx="83.3857" ry="18"/>
    <text text-anchor="middle" x="279.1413" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks_matched</text>
    </a>
    </g>
    </g>
    <!-- peaks_extended&#45;&gt;peaks_matched -->
    <g id="edge21" class="edge">
    <title>peaks_extended&#45;&gt;peaks_matched</title>
    <path fill="none" stroke="#000000" d="M279.1413,-575.8314C279.1413,-568.131 279.1413,-558.9743 279.1413,-550.4166"/>
    <polygon fill="#000000" stroke="#000000" points="282.6414,-550.4132 279.1413,-540.4133 275.6414,-550.4133 282.6414,-550.4132"/>
    </g>
    <!-- raw_records -->
    <g id="node5" class="node">
    <title>raw_records</title>
    <g id="a_node5"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="521.1413" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="521.1413" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- peaks -->
    <g id="node8" class="node">
    <title>peaks</title>
    <g id="a_node8"><a xlink:href="#peaks" xlink:title="peaks">
    <ellipse fill="#98fb98" stroke="#000000" cx="279.1413" cy="-378" rx="38.1938" ry="18"/>
    <text text-anchor="middle" x="279.1413" y="-374.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks</text>
    </a>
    </g>
    </g>
    <!-- peak_basics&#45;&gt;peaks -->
    <g id="edge8" class="edge">
    <title>peak_basics&#45;&gt;peaks</title>
    <path fill="none" stroke="#000000" d="M279.1413,-431.8314C279.1413,-424.131 279.1413,-414.9743 279.1413,-406.4166"/>
    <polygon fill="#000000" stroke="#000000" points="282.6414,-406.4132 279.1413,-396.4133 275.6414,-406.4133 282.6414,-406.4132"/>
    </g>
    <!-- peaks_matched&#45;&gt;truth -->
    <g id="edge6" class="edge">
    <title>peaks_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M238.9715,-506.0209C207.8649,-493.6469 165.1261,-476.6459 134.912,-464.627"/>
    <polygon fill="#000000" stroke="#000000" points="136.1584,-461.3561 125.5729,-460.912 133.5711,-467.8604 136.1584,-461.3561"/>
    </g>
    <!-- peaks_matched&#45;&gt;peak_basics -->
    <g id="edge7" class="edge">
    <title>peaks_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M279.1413,-503.8314C279.1413,-496.131 279.1413,-486.9743 279.1413,-478.4166"/>
    <polygon fill="#000000" stroke="#000000" points="282.6414,-478.4132 279.1413,-468.4133 275.6414,-478.4133 282.6414,-478.4132"/>
    </g>
    <!-- peaklets -->
    <g id="node9" class="node">
    <title>peaklets</title>
    <g id="a_node9"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="327.1413" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="327.1413" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklets -->
    <g id="edge9" class="edge">
    <title>peaks&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M261.2103,-361.5318C230.4922,-331.279 174.0724,-265.4292 206.1413,-216 220.842,-193.3411 247.5112,-180.1078 272.0778,-172.4205"/>
    <polygon fill="#000000" stroke="#000000" points="273.0768,-175.7751 281.7168,-169.6433 271.1387,-169.0488 273.0768,-175.7751"/>
    </g>
    <!-- peaklet_classification -->
    <g id="node10" class="node">
    <title>peaklet_classification</title>
    <g id="a_node10"><a xlink:href="#peaklet-classification" xlink:title="peaklet_classification">
    <ellipse fill="#d9ff66" stroke="#000000" cx="327.1413" cy="-234" rx="111.5806" ry="18"/>
    <text text-anchor="middle" x="327.1413" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklet_classification</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklet_classification -->
    <g id="edge10" class="edge">
    <title>peaks&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M281.4022,-359.9931C284.0751,-341.5194 289.3144,-312.148 298.1413,-288 301.4327,-278.9955 305.9992,-269.6408 310.5357,-261.2976"/>
    <polygon fill="#000000" stroke="#000000" points="313.7022,-262.8082 315.5751,-252.3802 307.608,-259.3642 313.7022,-262.8082"/>
    </g>
    <!-- merged_s2s -->
    <g id="node11" class="node">
    <title>merged_s2s</title>
    <g id="a_node11"><a xlink:href="#merged-s2s" xlink:title="merged_s2s">
    <ellipse fill="#ccffcc" stroke="#000000" cx="374.1413" cy="-306" rx="66.8882" ry="18"/>
    <text text-anchor="middle" x="374.1413" y="-302.3" font-family="Times,serif" font-size="14.00" fill="#000000">merged_s2s</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;merged_s2s -->
    <g id="edge11" class="edge">
    <title>peaks&#45;&gt;merged_s2s</title>
    <path fill="none" stroke="#000000" d="M299.7549,-362.3771C312.5279,-352.6965 329.1684,-340.0847 343.4709,-329.2449"/>
    <polygon fill="#000000" stroke="#000000" points="345.7193,-331.9326 351.5749,-323.1029 341.4911,-326.3538 345.7193,-331.9326"/>
    </g>
    <!-- records -->
    <g id="node12" class="node">
    <title>records</title>
    <g id="a_node12"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="387.1413" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="387.1413" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge12" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M341.6656,-144.5708C349.0355,-135.7269 358.1214,-124.8239 366.2293,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="369.0376,-117.1916 372.7507,-107.2687 363.6601,-112.7103 369.0376,-117.1916"/>
    </g>
    <!-- peaklet_classification&#45;&gt;peaklets -->
    <g id="edge17" class="edge">
    <title>peaklet_classification&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M327.1413,-215.8314C327.1413,-208.131 327.1413,-198.9743 327.1413,-190.4166"/>
    <polygon fill="#000000" stroke="#000000" points="330.6414,-190.4132 327.1413,-180.4133 323.6414,-190.4133 330.6414,-190.4132"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklets -->
    <g id="edge18" class="edge">
    <title>merged_s2s&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M408.0562,-290.4273C423.2522,-281.5104 439.6387,-268.7303 448.1413,-252 455.3903,-237.7363 456.8496,-229.4226 448.1413,-216 439.4703,-202.635 404.7608,-187.9245 374.7276,-177.2369"/>
    <polygon fill="#000000" stroke="#000000" points="375.7747,-173.8954 365.1798,-173.915 373.4744,-180.5067 375.7747,-173.8954"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklet_classification -->
    <g id="edge19" class="edge">
    <title>merged_s2s&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M362.5233,-288.2022C357.0849,-279.871 350.4943,-269.7748 344.4823,-260.565"/>
    <polygon fill="#000000" stroke="#000000" points="347.3492,-258.5537 338.9521,-252.0931 341.4875,-262.3801 347.3492,-258.5537"/>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge14" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M414.2582,-75.4297C433.6637,-65.0029 460.0874,-50.8051 481.8063,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="483.6399,-42.1233 490.7922,-34.307 480.3266,-35.9571 483.6399,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node13" class="node">
    <title>lone_hits</title>
    <g id="a_node13"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="448.1413" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="448.1413" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge13" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M433.3749,-144.5708C425.8821,-135.7269 416.6449,-124.8239 408.4019,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="410.9064,-112.6361 401.7717,-107.2687 405.5655,-117.161 410.9064,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node14" class="node">
    <title>veto_regions</title>
    <g id="a_node14"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="521.1413" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="521.1413" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge15" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M521.1413,-71.8314C521.1413,-64.131 521.1413,-54.9743 521.1413,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="524.6414,-46.4132 521.1413,-36.4133 517.6414,-46.4133 524.6414,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node15" class="node">
    <title>pulse_counts</title>
    <g id="a_node15"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="681.1413" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="681.1413" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge16" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M646.0286,-74.1993C622.2921,-63.5179 590.7606,-49.3287 565.3199,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="566.4522,-34.5519 555.8967,-33.6399 563.5796,-40.9353 566.4522,-34.5519"/>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaks,)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>dpe_fraction</td>          <td>0.219</td>          <td>&lt;OMITTED&gt;</td>          <td>(match_acceptance,)</td>          <td>Probability of double photon emission (conversion between n_photon in truth and area in peaks)</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>min_s2_bias_rec</td>          <td>0.65</td>          <td>&lt;OMITTED&gt;</td>          <td>(match_acceptance,)</td>          <td>If the</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>253</td>          <td>253</td>          <td>(peak_basics,)</td>          <td>Number of top PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>penalty_s2_by</td>          <td>((misid_as_s1, -1.0), (split_and_misid, -1.0))</td>          <td>&lt;OMITTED&gt;</td>          <td>(match_acceptance,)</td>          <td>Add a penalty to the acceptance fraction if the peak has the outcome. Should be tuple of tuples where each tuple should have the format of (outcome, penalty_factor)</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>s1_max_rise_time</td>          <td>60</td>          <td>100</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &lt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_max_rise_time_post100</td>          <td>150</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &gt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_min_coincidence</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum tight coincidence necessary to make an S1</td>        </tr>        <tr>          <td>s2_merge_max_area</td>          <td>5000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Merge peaklet cluster only if area &lt; this [PE]</td>        </tr>        <tr>          <td>s2_merge_max_duration</td>          <td>15000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Do not merge peaklets at all if the result would be a peak longer than this [ns]</td>        </tr>        <tr>          <td>s2_merge_max_gap</td>          <td>3500</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Maximum separation between peaklets to allow merging [ns]</td>        </tr>        <tr>          <td>s2_min_pmts</td>          <td>4</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum number of PMTs contributing to an S2</td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



peaks_extended
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `PeaksExtended <https://github.com/XENONnT/pema/blob/master/pema/match_plugins.py>`_

Data kind: peaks

Merge fields added in merging to peaks


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time of the peak (ns since unix epoch)</td>        </tr>        <tr>          <td>endtime</td>          <td>int64</td>          <td>End time of the peak (ns since unix epoch)</td>        </tr>        <tr>          <td>center_time</td>          <td>int64</td>          <td>Weighted center time of the peak (ns since unix epoch)</td>        </tr>        <tr>          <td>area</td>          <td>float32</td>          <td>Peak integral in PE</td>        </tr>        <tr>          <td>n_channels</td>          <td>int16</td>          <td>Number of PMTs contributing to the peak</td>        </tr>        <tr>          <td>max_pmt</td>          <td>int16</td>          <td>PMT number which contributes the most PE</td>        </tr>        <tr>          <td>max_pmt_area</td>          <td>float32</td>          <td>Area of signal in the largest-contributing PMT (PE)</td>        </tr>        <tr>          <td>range_50p_area</td>          <td>float32</td>          <td>Width (in ns) of the central 50% area of the peak</td>        </tr>        <tr>          <td>range_90p_area</td>          <td>float32</td>          <td>Width (in ns) of the central 90% area of the peak</td>        </tr>        <tr>          <td>area_fraction_top</td>          <td>float32</td>          <td>Fraction of area seen by the top array (NaN for peaks with non-positive area)</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the peak waveform in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Time resolution of the peak waveform in ns</td>        </tr>        <tr>          <td>rise_time</td>          <td>float32</td>          <td>Time between 10% and 50% area quantiles [ns]</td>        </tr>        <tr>          <td>tight_coincidence</td>          <td>int16</td>          <td>Hits within tight range of mean</td>        </tr>        <tr>          <td>type</td>          <td>int8</td>          <td>Classification of the peak(let)</td>        </tr>        <tr>          <td>id</td>          <td>int64</td>          <td>Id of element in peaks</td>        </tr>        <tr>          <td>outcome</td>          <td>&lt;U32</td>          <td>Outcome of matching to truth</td>        </tr>        <tr>          <td>matched_to</td>          <td>int64</td>          <td>Id of matching element in truth</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="746pt" height="620pt"
     viewBox="0.00 0.00 745.69 620.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 616)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-616 741.6863,-616 741.6863,4 -4,4"/>
    <!-- peaks_extended -->
    <g id="node1" class="node">
    <title>peaks_extended</title>
    <g id="a_node1"><a xlink:href="#peaks-extended" xlink:title="peaks_extended">
    <ellipse fill="#98fb98" stroke="#000000" cx="227.1926" cy="-594" rx="85.5853" ry="18"/>
    <text text-anchor="middle" x="227.1926" y="-590.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks_extended</text>
    </a>
    </g>
    </g>
    <!-- peak_basics -->
    <g id="node2" class="node">
    <title>peak_basics</title>
    <g id="a_node2"><a xlink:href="#peak-basics" xlink:title="peak_basics">
    <ellipse fill="#98fb98" stroke="#000000" cx="264.1926" cy="-450" rx="67.6881" ry="18"/>
    <text text-anchor="middle" x="264.1926" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">peak_basics</text>
    </a>
    </g>
    </g>
    <!-- peaks_extended&#45;&gt;peak_basics -->
    <g id="edge1" class="edge">
    <title>peaks_extended&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M291.3108,-582.0206C314.8624,-574.181 339.1742,-561.2594 353.1926,-540 362.0005,-526.6425 361.0414,-517.9426 353.1926,-504 344.676,-488.871 330.0191,-477.4925 315.0293,-469.18"/>
    <polygon fill="#000000" stroke="#000000" points="316.1998,-465.8468 305.7049,-464.3945 313.0035,-472.0744 316.1998,-465.8468"/>
    </g>
    <!-- peaks_matched -->
    <g id="node3" class="node">
    <title>peaks_matched</title>
    <g id="a_node3"><a xlink:href="#peaks-matched" xlink:title="peaks_matched">
    <ellipse fill="#98fb98" stroke="#000000" cx="83.1926" cy="-522" rx="83.3857" ry="18"/>
    <text text-anchor="middle" x="83.1926" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks_matched</text>
    </a>
    </g>
    </g>
    <!-- peaks_extended&#45;&gt;peaks_matched -->
    <g id="edge2" class="edge">
    <title>peaks_extended&#45;&gt;peaks_matched</title>
    <path fill="none" stroke="#000000" d="M193.7942,-577.3008C173.4386,-567.123 147.2387,-554.023 125.4486,-543.128"/>
    <polygon fill="#000000" stroke="#000000" points="126.9195,-539.9504 116.4099,-538.6087 123.789,-546.2113 126.9195,-539.9504"/>
    </g>
    <!-- peaks -->
    <g id="node4" class="node">
    <title>peaks</title>
    <g id="a_node4"><a xlink:href="#peaks" xlink:title="peaks">
    <ellipse fill="#98fb98" stroke="#000000" cx="264.1926" cy="-378" rx="38.1938" ry="18"/>
    <text text-anchor="middle" x="264.1926" y="-374.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks</text>
    </a>
    </g>
    </g>
    <!-- peak_basics&#45;&gt;peaks -->
    <g id="edge3" class="edge">
    <title>peak_basics&#45;&gt;peaks</title>
    <path fill="none" stroke="#000000" d="M264.1926,-431.8314C264.1926,-424.131 264.1926,-414.9743 264.1926,-406.4166"/>
    <polygon fill="#000000" stroke="#000000" points="267.6927,-406.4132 264.1926,-396.4133 260.6927,-406.4133 267.6927,-406.4132"/>
    </g>
    <!-- peaks_matched&#45;&gt;peak_basics -->
    <g id="edge18" class="edge">
    <title>peaks_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M123.3624,-506.0209C150.9658,-495.0405 187.7289,-480.4165 216.7718,-468.8635"/>
    <polygon fill="#000000" stroke="#000000" points="218.3026,-472.0214 226.3008,-465.073 215.7152,-465.5171 218.3026,-472.0214"/>
    </g>
    <!-- truth -->
    <g id="node13" class="node">
    <title>truth</title>
    <g id="a_node13"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="114.1926" cy="-450" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="114.1926" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    <!-- peaks_matched&#45;&gt;truth -->
    <g id="edge17" class="edge">
    <title>peaks_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M91.0152,-503.8314C94.4927,-495.7547 98.6598,-486.0761 102.4958,-477.1668"/>
    <polygon fill="#000000" stroke="#000000" points="105.74,-478.4824 106.4799,-467.9134 99.3106,-475.7141 105.74,-478.4824"/>
    </g>
    <!-- peaklets -->
    <g id="node5" class="node">
    <title>peaklets</title>
    <g id="a_node5"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="312.1926" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="312.1926" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklets -->
    <g id="edge4" class="edge">
    <title>peaks&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M246.2616,-361.5318C215.5435,-331.279 159.1237,-265.4292 191.1926,-216 205.8933,-193.3411 232.5625,-180.1078 257.1291,-172.4205"/>
    <polygon fill="#000000" stroke="#000000" points="258.1281,-175.7751 266.7682,-169.6433 256.19,-169.0488 258.1281,-175.7751"/>
    </g>
    <!-- peaklet_classification -->
    <g id="node6" class="node">
    <title>peaklet_classification</title>
    <g id="a_node6"><a xlink:href="#peaklet-classification" xlink:title="peaklet_classification">
    <ellipse fill="#d9ff66" stroke="#000000" cx="312.1926" cy="-234" rx="111.5806" ry="18"/>
    <text text-anchor="middle" x="312.1926" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklet_classification</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklet_classification -->
    <g id="edge5" class="edge">
    <title>peaks&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M266.4535,-359.9931C269.1264,-341.5194 274.3657,-312.148 283.1926,-288 286.4841,-278.9955 291.0506,-269.6408 295.587,-261.2976"/>
    <polygon fill="#000000" stroke="#000000" points="298.7535,-262.8082 300.6265,-252.3802 292.6593,-259.3642 298.7535,-262.8082"/>
    </g>
    <!-- merged_s2s -->
    <g id="node7" class="node">
    <title>merged_s2s</title>
    <g id="a_node7"><a xlink:href="#merged-s2s" xlink:title="merged_s2s">
    <ellipse fill="#ccffcc" stroke="#000000" cx="359.1926" cy="-306" rx="66.8882" ry="18"/>
    <text text-anchor="middle" x="359.1926" y="-302.3" font-family="Times,serif" font-size="14.00" fill="#000000">merged_s2s</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;merged_s2s -->
    <g id="edge6" class="edge">
    <title>peaks&#45;&gt;merged_s2s</title>
    <path fill="none" stroke="#000000" d="M284.8062,-362.3771C297.5792,-352.6965 314.2197,-340.0847 328.5222,-329.2449"/>
    <polygon fill="#000000" stroke="#000000" points="330.7706,-331.9326 336.6263,-323.1029 326.5425,-326.3538 330.7706,-331.9326"/>
    </g>
    <!-- records -->
    <g id="node8" class="node">
    <title>records</title>
    <g id="a_node8"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="372.1926" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="372.1926" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge7" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M326.7169,-144.5708C334.0869,-135.7269 343.1727,-124.8239 351.2806,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="354.0889,-117.1916 357.802,-107.2687 348.7114,-112.7103 354.0889,-117.1916"/>
    </g>
    <!-- peaklet_classification&#45;&gt;peaklets -->
    <g id="edge12" class="edge">
    <title>peaklet_classification&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M312.1926,-215.8314C312.1926,-208.131 312.1926,-198.9743 312.1926,-190.4166"/>
    <polygon fill="#000000" stroke="#000000" points="315.6927,-190.4132 312.1926,-180.4133 308.6927,-190.4133 315.6927,-190.4132"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklets -->
    <g id="edge13" class="edge">
    <title>merged_s2s&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M393.1075,-290.4273C408.3035,-281.5104 424.69,-268.7303 433.1926,-252 440.4416,-237.7363 441.901,-229.4226 433.1926,-216 424.5216,-202.635 389.8122,-187.9245 359.779,-177.2369"/>
    <polygon fill="#000000" stroke="#000000" points="360.826,-173.8954 350.2312,-173.915 358.5258,-180.5067 360.826,-173.8954"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklet_classification -->
    <g id="edge14" class="edge">
    <title>merged_s2s&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M347.5746,-288.2022C342.1362,-279.871 335.5456,-269.7748 329.5337,-260.565"/>
    <polygon fill="#000000" stroke="#000000" points="332.4005,-258.5537 324.0034,-252.0931 326.5388,-262.3801 332.4005,-258.5537"/>
    </g>
    <!-- raw_records -->
    <g id="node10" class="node">
    <title>raw_records</title>
    <g id="a_node10"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="506.1926" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="506.1926" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge9" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M399.3095,-75.4297C418.715,-65.0029 445.1387,-50.8051 466.8576,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="468.6912,-42.1233 475.8435,-34.307 465.3779,-35.9571 468.6912,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node9" class="node">
    <title>lone_hits</title>
    <g id="a_node9"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="433.1926" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="433.1926" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge8" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M418.4262,-144.5708C410.9335,-135.7269 401.6962,-124.8239 393.4532,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="395.9577,-112.6361 386.823,-107.2687 390.6168,-117.161 395.9577,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node11" class="node">
    <title>veto_regions</title>
    <g id="a_node11"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="506.1926" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="506.1926" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge10" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M506.1926,-71.8314C506.1926,-64.131 506.1926,-54.9743 506.1926,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="509.6927,-46.4132 506.1926,-36.4133 502.6927,-46.4133 509.6927,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node12" class="node">
    <title>pulse_counts</title>
    <g id="a_node12"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="666.1926" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="666.1926" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge11" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M631.0799,-74.1993C607.3434,-63.5179 575.8119,-49.3287 550.3712,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="551.5035,-34.5519 540.948,-33.6399 548.6309,-40.9353 551.5035,-34.5519"/>
    </g>
    <!-- truth_matched -->
    <g id="node14" class="node">
    <title>truth_matched</title>
    <g id="a_node14"><a xlink:href="#truth-matched" xlink:title="truth_matched">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="264.1926" cy="-522" rx="79.8859" ry="18"/>
    <text text-anchor="middle" x="264.1926" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth_matched</text>
    </a>
    </g>
    </g>
    <!-- truth_matched&#45;&gt;peak_basics -->
    <g id="edge16" class="edge">
    <title>truth_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M264.1926,-503.8314C264.1926,-496.131 264.1926,-486.9743 264.1926,-478.4166"/>
    <polygon fill="#000000" stroke="#000000" points="267.6927,-478.4132 264.1926,-468.4133 260.6927,-478.4133 267.6927,-478.4132"/>
    </g>
    <!-- truth_matched&#45;&gt;truth -->
    <g id="edge15" class="edge">
    <title>truth_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M230.1553,-505.6621C205.8892,-494.0143 173.3703,-478.4053 148.9443,-466.6808"/>
    <polygon fill="#000000" stroke="#000000" points="150.213,-463.4075 139.6832,-462.2355 147.1839,-469.7182 150.213,-463.4075"/>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaks,)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>253</td>          <td>253</td>          <td>(peak_basics,)</td>          <td>Number of top PMTs</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>s1_max_rise_time</td>          <td>60</td>          <td>100</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &lt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_max_rise_time_post100</td>          <td>150</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &gt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_min_coincidence</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum tight coincidence necessary to make an S1</td>        </tr>        <tr>          <td>s2_merge_max_area</td>          <td>5000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Merge peaklet cluster only if area &lt; this [PE]</td>        </tr>        <tr>          <td>s2_merge_max_duration</td>          <td>15000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Do not merge peaklets at all if the result would be a peak longer than this [ns]</td>        </tr>        <tr>          <td>s2_merge_max_gap</td>          <td>3500</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Maximum separation between peaklets to allow merging [ns]</td>        </tr>        <tr>          <td>s2_min_pmts</td>          <td>4</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum number of PMTs contributing to an S2</td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



truth_matched
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `MatchPeaks <https://github.com/XENONnT/pema/blob/master/pema/match_plugins.py>`_

Data kind: truth


    Match WFSim truth to the outcome peaks. To this end use the
        matching algorithm of pema. Assign a peak-id to both the truth
        and the reconstructed peaks to be able to match the two. Also
        define the outcome of the matching (see pema.matching for
        possible outcomes).
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>endtime</td>          <td>int64</td>          <td>Exclusive end time since unix epoch [ns]</td>        </tr>        <tr>          <td>id</td>          <td>int64</td>          <td>Id of element in truth</td>        </tr>        <tr>          <td>outcome</td>          <td>&lt;U32</td>          <td>Outcome of matching to peaks</td>        </tr>        <tr>          <td>matched_to</td>          <td>int64</td>          <td>Id of matching element in peaks</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="726pt" height="548pt"
     viewBox="0.00 0.00 726.44 548.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 544)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-544 722.4366,-544 722.4366,4 -4,4"/>
    <!-- truth_matched -->
    <g id="node1" class="node">
    <title>truth_matched</title>
    <g id="a_node1"><a xlink:href="#truth-matched" xlink:title="truth_matched">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="79.9429" cy="-522" rx="79.8859" ry="18"/>
    <text text-anchor="middle" x="79.9429" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth_matched</text>
    </a>
    </g>
    </g>
    <!-- truth -->
    <g id="node2" class="node">
    <title>truth</title>
    <g id="a_node2"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="109.9429" cy="-450" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="109.9429" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    <!-- truth_matched&#45;&gt;truth -->
    <g id="edge1" class="edge">
    <title>truth_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M87.5132,-503.8314C90.8784,-495.7547 94.9112,-486.0761 98.6234,-477.1668"/>
    <polygon fill="#000000" stroke="#000000" points="101.8635,-478.4904 102.479,-467.9134 95.402,-475.798 101.8635,-478.4904"/>
    </g>
    <!-- peak_basics -->
    <g id="node3" class="node">
    <title>peak_basics</title>
    <g id="a_node3"><a xlink:href="#peak-basics" xlink:title="peak_basics">
    <ellipse fill="#98fb98" stroke="#000000" cx="244.9429" cy="-450" rx="67.6881" ry="18"/>
    <text text-anchor="middle" x="244.9429" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">peak_basics</text>
    </a>
    </g>
    </g>
    <!-- truth_matched&#45;&gt;peak_basics -->
    <g id="edge2" class="edge">
    <title>truth_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M116.9721,-505.8418C141.5972,-495.0963 174.0825,-480.9209 200.1606,-469.5413"/>
    <polygon fill="#000000" stroke="#000000" points="201.6865,-472.6943 209.4521,-465.4869 198.8868,-466.2785 201.6865,-472.6943"/>
    </g>
    <!-- peaks -->
    <g id="node6" class="node">
    <title>peaks</title>
    <g id="a_node6"><a xlink:href="#peaks" xlink:title="peaks">
    <ellipse fill="#98fb98" stroke="#000000" cx="244.9429" cy="-378" rx="38.1938" ry="18"/>
    <text text-anchor="middle" x="244.9429" y="-374.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks</text>
    </a>
    </g>
    </g>
    <!-- peak_basics&#45;&gt;peaks -->
    <g id="edge5" class="edge">
    <title>peak_basics&#45;&gt;peaks</title>
    <path fill="none" stroke="#000000" d="M244.9429,-431.8314C244.9429,-424.131 244.9429,-414.9743 244.9429,-406.4166"/>
    <polygon fill="#000000" stroke="#000000" points="248.443,-406.4132 244.9429,-396.4133 241.443,-406.4133 248.443,-406.4132"/>
    </g>
    <!-- peaks_matched -->
    <g id="node4" class="node">
    <title>peaks_matched</title>
    <g id="a_node4"><a xlink:href="#peaks-matched" xlink:title="peaks_matched">
    <ellipse fill="#98fb98" stroke="#000000" cx="260.9429" cy="-522" rx="83.3857" ry="18"/>
    <text text-anchor="middle" x="260.9429" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks_matched</text>
    </a>
    </g>
    </g>
    <!-- peaks_matched&#45;&gt;truth -->
    <g id="edge3" class="edge">
    <title>peaks_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M226.3005,-505.4817C201.8566,-493.8264 169.2363,-478.2723 144.7548,-466.599"/>
    <polygon fill="#000000" stroke="#000000" points="146.0067,-463.3185 135.4739,-462.1737 142.9939,-469.637 146.0067,-463.3185"/>
    </g>
    <!-- peaks_matched&#45;&gt;peak_basics -->
    <g id="edge4" class="edge">
    <title>peaks_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M256.9054,-503.8314C255.1942,-496.131 253.1594,-486.9743 251.2577,-478.4166"/>
    <polygon fill="#000000" stroke="#000000" points="254.6208,-477.4159 249.0347,-468.4133 247.7875,-478.9344 254.6208,-477.4159"/>
    </g>
    <!-- raw_records -->
    <g id="node5" class="node">
    <title>raw_records</title>
    <g id="a_node5"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="486.9429" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="486.9429" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- peaklets -->
    <g id="node7" class="node">
    <title>peaklets</title>
    <g id="a_node7"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="292.9429" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="292.9429" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklets -->
    <g id="edge6" class="edge">
    <title>peaks&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M227.0119,-361.5318C196.2938,-331.279 139.874,-265.4292 171.9429,-216 186.6436,-193.3411 213.3128,-180.1078 237.8794,-172.4205"/>
    <polygon fill="#000000" stroke="#000000" points="238.8784,-175.7751 247.5185,-169.6433 236.9403,-169.0488 238.8784,-175.7751"/>
    </g>
    <!-- peaklet_classification -->
    <g id="node8" class="node">
    <title>peaklet_classification</title>
    <g id="a_node8"><a xlink:href="#peaklet-classification" xlink:title="peaklet_classification">
    <ellipse fill="#d9ff66" stroke="#000000" cx="292.9429" cy="-234" rx="111.5806" ry="18"/>
    <text text-anchor="middle" x="292.9429" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklet_classification</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklet_classification -->
    <g id="edge7" class="edge">
    <title>peaks&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M247.2038,-359.9931C249.8767,-341.5194 255.116,-312.148 263.9429,-288 267.2344,-278.9955 271.8009,-269.6408 276.3373,-261.2976"/>
    <polygon fill="#000000" stroke="#000000" points="279.5038,-262.8082 281.3767,-252.3802 273.4096,-259.3642 279.5038,-262.8082"/>
    </g>
    <!-- merged_s2s -->
    <g id="node9" class="node">
    <title>merged_s2s</title>
    <g id="a_node9"><a xlink:href="#merged-s2s" xlink:title="merged_s2s">
    <ellipse fill="#ccffcc" stroke="#000000" cx="339.9429" cy="-306" rx="66.8882" ry="18"/>
    <text text-anchor="middle" x="339.9429" y="-302.3" font-family="Times,serif" font-size="14.00" fill="#000000">merged_s2s</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;merged_s2s -->
    <g id="edge8" class="edge">
    <title>peaks&#45;&gt;merged_s2s</title>
    <path fill="none" stroke="#000000" d="M265.5565,-362.3771C278.3295,-352.6965 294.97,-340.0847 309.2725,-329.2449"/>
    <polygon fill="#000000" stroke="#000000" points="311.5209,-331.9326 317.3765,-323.1029 307.2927,-326.3538 311.5209,-331.9326"/>
    </g>
    <!-- records -->
    <g id="node10" class="node">
    <title>records</title>
    <g id="a_node10"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="352.9429" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="352.9429" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge9" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M307.4672,-144.5708C314.8372,-135.7269 323.923,-124.8239 332.0309,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="334.8392,-117.1916 338.5523,-107.2687 329.4617,-112.7103 334.8392,-117.1916"/>
    </g>
    <!-- peaklet_classification&#45;&gt;peaklets -->
    <g id="edge14" class="edge">
    <title>peaklet_classification&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M292.9429,-215.8314C292.9429,-208.131 292.9429,-198.9743 292.9429,-190.4166"/>
    <polygon fill="#000000" stroke="#000000" points="296.443,-190.4132 292.9429,-180.4133 289.443,-190.4133 296.443,-190.4132"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklets -->
    <g id="edge15" class="edge">
    <title>merged_s2s&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M373.8578,-290.4273C389.0538,-281.5104 405.4403,-268.7303 413.9429,-252 421.1919,-237.7363 422.6512,-229.4226 413.9429,-216 405.2719,-202.635 370.5624,-187.9245 340.5292,-177.2369"/>
    <polygon fill="#000000" stroke="#000000" points="341.5763,-173.8954 330.9815,-173.915 339.276,-180.5067 341.5763,-173.8954"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklet_classification -->
    <g id="edge16" class="edge">
    <title>merged_s2s&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M328.3249,-288.2022C322.8865,-279.871 316.2959,-269.7748 310.284,-260.565"/>
    <polygon fill="#000000" stroke="#000000" points="313.1508,-258.5537 304.7537,-252.0931 307.2891,-262.3801 313.1508,-258.5537"/>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge11" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M380.0598,-75.4297C399.4653,-65.0029 425.889,-50.8051 447.6079,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="449.4415,-42.1233 456.5938,-34.307 446.1282,-35.9571 449.4415,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node11" class="node">
    <title>lone_hits</title>
    <g id="a_node11"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="413.9429" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="413.9429" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge10" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M399.1765,-144.5708C391.6838,-135.7269 382.4465,-124.8239 374.2035,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="376.708,-112.6361 367.5733,-107.2687 371.3671,-117.161 376.708,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node12" class="node">
    <title>veto_regions</title>
    <g id="a_node12"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="486.9429" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="486.9429" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge12" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M486.9429,-71.8314C486.9429,-64.131 486.9429,-54.9743 486.9429,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="490.443,-46.4132 486.9429,-36.4133 483.443,-46.4133 490.443,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node13" class="node">
    <title>pulse_counts</title>
    <g id="a_node13"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="646.9429" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="646.9429" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge13" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M611.8302,-74.1993C588.0937,-63.5179 556.5622,-49.3287 531.1215,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="532.2538,-34.5519 521.6983,-33.6399 529.3812,-40.9353 532.2538,-34.5519"/>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaks,)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>253</td>          <td>253</td>          <td>(peak_basics,)</td>          <td>Number of top PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>s1_max_rise_time</td>          <td>60</td>          <td>100</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &lt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_max_rise_time_post100</td>          <td>150</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &gt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_min_coincidence</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum tight coincidence necessary to make an S1</td>        </tr>        <tr>          <td>s2_merge_max_area</td>          <td>5000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Merge peaklet cluster only if area &lt; this [PE]</td>        </tr>        <tr>          <td>s2_merge_max_duration</td>          <td>15000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Do not merge peaklets at all if the result would be a peak longer than this [ns]</td>        </tr>        <tr>          <td>s2_merge_max_gap</td>          <td>3500</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Maximum separation between peaklets to allow merging [ns]</td>        </tr>        <tr>          <td>s2_min_pmts</td>          <td>4</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum number of PMTs contributing to an S2</td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



peaks_matched
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `MatchPeaks <https://github.com/XENONnT/pema/blob/master/pema/match_plugins.py>`_

Data kind: peaks


    Match WFSim truth to the outcome peaks. To this end use the
        matching algorithm of pema. Assign a peak-id to both the truth
        and the reconstructed peaks to be able to match the two. Also
        define the outcome of the matching (see pema.matching for
        possible outcomes).
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>endtime</td>          <td>int64</td>          <td>Exclusive end time since unix epoch [ns]</td>        </tr>        <tr>          <td>id</td>          <td>int64</td>          <td>Id of element in peaks</td>        </tr>        <tr>          <td>outcome</td>          <td>&lt;U32</td>          <td>Outcome of matching to truth</td>        </tr>        <tr>          <td>matched_to</td>          <td>int64</td>          <td>Id of matching element in truth</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="726pt" height="548pt"
     viewBox="0.00 0.00 726.44 548.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 544)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-544 722.4366,-544 722.4366,4 -4,4"/>
    <!-- truth_matched -->
    <g id="node1" class="node">
    <title>truth_matched</title>
    <g id="a_node1"><a xlink:href="#truth-matched" xlink:title="truth_matched">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="79.9429" cy="-522" rx="79.8859" ry="18"/>
    <text text-anchor="middle" x="79.9429" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth_matched</text>
    </a>
    </g>
    </g>
    <!-- truth -->
    <g id="node2" class="node">
    <title>truth</title>
    <g id="a_node2"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="109.9429" cy="-450" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="109.9429" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    <!-- truth_matched&#45;&gt;truth -->
    <g id="edge1" class="edge">
    <title>truth_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M87.5132,-503.8314C90.8784,-495.7547 94.9112,-486.0761 98.6234,-477.1668"/>
    <polygon fill="#000000" stroke="#000000" points="101.8635,-478.4904 102.479,-467.9134 95.402,-475.798 101.8635,-478.4904"/>
    </g>
    <!-- peak_basics -->
    <g id="node3" class="node">
    <title>peak_basics</title>
    <g id="a_node3"><a xlink:href="#peak-basics" xlink:title="peak_basics">
    <ellipse fill="#98fb98" stroke="#000000" cx="244.9429" cy="-450" rx="67.6881" ry="18"/>
    <text text-anchor="middle" x="244.9429" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">peak_basics</text>
    </a>
    </g>
    </g>
    <!-- truth_matched&#45;&gt;peak_basics -->
    <g id="edge2" class="edge">
    <title>truth_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M116.9721,-505.8418C141.5972,-495.0963 174.0825,-480.9209 200.1606,-469.5413"/>
    <polygon fill="#000000" stroke="#000000" points="201.6865,-472.6943 209.4521,-465.4869 198.8868,-466.2785 201.6865,-472.6943"/>
    </g>
    <!-- peaks -->
    <g id="node6" class="node">
    <title>peaks</title>
    <g id="a_node6"><a xlink:href="#peaks" xlink:title="peaks">
    <ellipse fill="#98fb98" stroke="#000000" cx="244.9429" cy="-378" rx="38.1938" ry="18"/>
    <text text-anchor="middle" x="244.9429" y="-374.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks</text>
    </a>
    </g>
    </g>
    <!-- peak_basics&#45;&gt;peaks -->
    <g id="edge5" class="edge">
    <title>peak_basics&#45;&gt;peaks</title>
    <path fill="none" stroke="#000000" d="M244.9429,-431.8314C244.9429,-424.131 244.9429,-414.9743 244.9429,-406.4166"/>
    <polygon fill="#000000" stroke="#000000" points="248.443,-406.4132 244.9429,-396.4133 241.443,-406.4133 248.443,-406.4132"/>
    </g>
    <!-- peaks_matched -->
    <g id="node4" class="node">
    <title>peaks_matched</title>
    <g id="a_node4"><a xlink:href="#peaks-matched" xlink:title="peaks_matched">
    <ellipse fill="#98fb98" stroke="#000000" cx="260.9429" cy="-522" rx="83.3857" ry="18"/>
    <text text-anchor="middle" x="260.9429" y="-518.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks_matched</text>
    </a>
    </g>
    </g>
    <!-- peaks_matched&#45;&gt;truth -->
    <g id="edge3" class="edge">
    <title>peaks_matched&#45;&gt;truth</title>
    <path fill="none" stroke="#000000" d="M226.3005,-505.4817C201.8566,-493.8264 169.2363,-478.2723 144.7548,-466.599"/>
    <polygon fill="#000000" stroke="#000000" points="146.0067,-463.3185 135.4739,-462.1737 142.9939,-469.637 146.0067,-463.3185"/>
    </g>
    <!-- peaks_matched&#45;&gt;peak_basics -->
    <g id="edge4" class="edge">
    <title>peaks_matched&#45;&gt;peak_basics</title>
    <path fill="none" stroke="#000000" d="M256.9054,-503.8314C255.1942,-496.131 253.1594,-486.9743 251.2577,-478.4166"/>
    <polygon fill="#000000" stroke="#000000" points="254.6208,-477.4159 249.0347,-468.4133 247.7875,-478.9344 254.6208,-477.4159"/>
    </g>
    <!-- raw_records -->
    <g id="node5" class="node">
    <title>raw_records</title>
    <g id="a_node5"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="486.9429" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="486.9429" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- peaklets -->
    <g id="node7" class="node">
    <title>peaklets</title>
    <g id="a_node7"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="292.9429" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="292.9429" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklets -->
    <g id="edge6" class="edge">
    <title>peaks&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M227.0119,-361.5318C196.2938,-331.279 139.874,-265.4292 171.9429,-216 186.6436,-193.3411 213.3128,-180.1078 237.8794,-172.4205"/>
    <polygon fill="#000000" stroke="#000000" points="238.8784,-175.7751 247.5185,-169.6433 236.9403,-169.0488 238.8784,-175.7751"/>
    </g>
    <!-- peaklet_classification -->
    <g id="node8" class="node">
    <title>peaklet_classification</title>
    <g id="a_node8"><a xlink:href="#peaklet-classification" xlink:title="peaklet_classification">
    <ellipse fill="#d9ff66" stroke="#000000" cx="292.9429" cy="-234" rx="111.5806" ry="18"/>
    <text text-anchor="middle" x="292.9429" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklet_classification</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklet_classification -->
    <g id="edge7" class="edge">
    <title>peaks&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M247.2038,-359.9931C249.8767,-341.5194 255.116,-312.148 263.9429,-288 267.2344,-278.9955 271.8009,-269.6408 276.3373,-261.2976"/>
    <polygon fill="#000000" stroke="#000000" points="279.5038,-262.8082 281.3767,-252.3802 273.4096,-259.3642 279.5038,-262.8082"/>
    </g>
    <!-- merged_s2s -->
    <g id="node9" class="node">
    <title>merged_s2s</title>
    <g id="a_node9"><a xlink:href="#merged-s2s" xlink:title="merged_s2s">
    <ellipse fill="#ccffcc" stroke="#000000" cx="339.9429" cy="-306" rx="66.8882" ry="18"/>
    <text text-anchor="middle" x="339.9429" y="-302.3" font-family="Times,serif" font-size="14.00" fill="#000000">merged_s2s</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;merged_s2s -->
    <g id="edge8" class="edge">
    <title>peaks&#45;&gt;merged_s2s</title>
    <path fill="none" stroke="#000000" d="M265.5565,-362.3771C278.3295,-352.6965 294.97,-340.0847 309.2725,-329.2449"/>
    <polygon fill="#000000" stroke="#000000" points="311.5209,-331.9326 317.3765,-323.1029 307.2927,-326.3538 311.5209,-331.9326"/>
    </g>
    <!-- records -->
    <g id="node10" class="node">
    <title>records</title>
    <g id="a_node10"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="352.9429" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="352.9429" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge9" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M307.4672,-144.5708C314.8372,-135.7269 323.923,-124.8239 332.0309,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="334.8392,-117.1916 338.5523,-107.2687 329.4617,-112.7103 334.8392,-117.1916"/>
    </g>
    <!-- peaklet_classification&#45;&gt;peaklets -->
    <g id="edge14" class="edge">
    <title>peaklet_classification&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M292.9429,-215.8314C292.9429,-208.131 292.9429,-198.9743 292.9429,-190.4166"/>
    <polygon fill="#000000" stroke="#000000" points="296.443,-190.4132 292.9429,-180.4133 289.443,-190.4133 296.443,-190.4132"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklets -->
    <g id="edge15" class="edge">
    <title>merged_s2s&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M373.8578,-290.4273C389.0538,-281.5104 405.4403,-268.7303 413.9429,-252 421.1919,-237.7363 422.6512,-229.4226 413.9429,-216 405.2719,-202.635 370.5624,-187.9245 340.5292,-177.2369"/>
    <polygon fill="#000000" stroke="#000000" points="341.5763,-173.8954 330.9815,-173.915 339.276,-180.5067 341.5763,-173.8954"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklet_classification -->
    <g id="edge16" class="edge">
    <title>merged_s2s&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M328.3249,-288.2022C322.8865,-279.871 316.2959,-269.7748 310.284,-260.565"/>
    <polygon fill="#000000" stroke="#000000" points="313.1508,-258.5537 304.7537,-252.0931 307.2891,-262.3801 313.1508,-258.5537"/>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge11" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M380.0598,-75.4297C399.4653,-65.0029 425.889,-50.8051 447.6079,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="449.4415,-42.1233 456.5938,-34.307 446.1282,-35.9571 449.4415,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node11" class="node">
    <title>lone_hits</title>
    <g id="a_node11"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="413.9429" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="413.9429" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge10" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M399.1765,-144.5708C391.6838,-135.7269 382.4465,-124.8239 374.2035,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="376.708,-112.6361 367.5733,-107.2687 371.3671,-117.161 376.708,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node12" class="node">
    <title>veto_regions</title>
    <g id="a_node12"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="486.9429" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="486.9429" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge12" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M486.9429,-71.8314C486.9429,-64.131 486.9429,-54.9743 486.9429,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="490.443,-46.4132 486.9429,-36.4133 483.443,-46.4133 490.443,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node13" class="node">
    <title>pulse_counts</title>
    <g id="a_node13"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="646.9429" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="646.9429" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge13" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M611.8302,-74.1993C588.0937,-63.5179 556.5622,-49.3287 531.1215,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="532.2538,-34.5519 521.6983,-33.6399 529.3812,-40.9353 532.2538,-34.5519"/>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaks,)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>253</td>          <td>253</td>          <td>(peak_basics,)</td>          <td>Number of top PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>s1_max_rise_time</td>          <td>60</td>          <td>100</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &lt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_max_rise_time_post100</td>          <td>150</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &gt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_min_coincidence</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum tight coincidence necessary to make an S1</td>        </tr>        <tr>          <td>s2_merge_max_area</td>          <td>5000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Merge peaklet cluster only if area &lt; this [PE]</td>        </tr>        <tr>          <td>s2_merge_max_duration</td>          <td>15000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Do not merge peaklets at all if the result would be a peak longer than this [ns]</td>        </tr>        <tr>          <td>s2_merge_max_gap</td>          <td>3500</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Maximum separation between peaklets to allow merging [ns]</td>        </tr>        <tr>          <td>s2_min_pmts</td>          <td>4</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum number of PMTs contributing to an S2</td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



peak_basics
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `PeakBasics <https://github.com/XENONnT/straxen/blob/master/straxen/plugins/peak_processing.py>`_

Data kind: peaks


    Compute the basic peak-properties, thereby dropping structured
    arrays.
    NB: This plugin can therefore be loaded as a pandas DataFrame.
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time of the peak (ns since unix epoch)</td>        </tr>        <tr>          <td>endtime</td>          <td>int64</td>          <td>End time of the peak (ns since unix epoch)</td>        </tr>        <tr>          <td>center_time</td>          <td>int64</td>          <td>Weighted center time of the peak (ns since unix epoch)</td>        </tr>        <tr>          <td>area</td>          <td>float32</td>          <td>Peak integral in PE</td>        </tr>        <tr>          <td>n_channels</td>          <td>int16</td>          <td>Number of PMTs contributing to the peak</td>        </tr>        <tr>          <td>max_pmt</td>          <td>int16</td>          <td>PMT number which contributes the most PE</td>        </tr>        <tr>          <td>max_pmt_area</td>          <td>float32</td>          <td>Area of signal in the largest-contributing PMT (PE)</td>        </tr>        <tr>          <td>range_50p_area</td>          <td>float32</td>          <td>Width (in ns) of the central 50% area of the peak</td>        </tr>        <tr>          <td>range_90p_area</td>          <td>float32</td>          <td>Width (in ns) of the central 90% area of the peak</td>        </tr>        <tr>          <td>area_fraction_top</td>          <td>float32</td>          <td>Fraction of area seen by the top array (NaN for peaks with non-positive area)</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the peak waveform in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Time resolution of the peak waveform in ns</td>        </tr>        <tr>          <td>rise_time</td>          <td>float32</td>          <td>Time between 10% and 50% area quantiles [ns]</td>        </tr>        <tr>          <td>tight_coincidence</td>          <td>int16</td>          <td>Hits within tight range of mean</td>        </tr>        <tr>          <td>type</td>          <td>int8</td>          <td>Classification of the peak(let)</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="564pt" height="476pt"
     viewBox="0.00 0.00 564.37 476.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 472)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-472 560.3677,-472 560.3677,4 -4,4"/>
    <!-- peak_basics -->
    <g id="node1" class="node">
    <title>peak_basics</title>
    <g id="a_node1"><a xlink:href="#peak-basics" xlink:title="peak_basics">
    <ellipse fill="#98fb98" stroke="#000000" cx="82.8741" cy="-450" rx="67.6881" ry="18"/>
    <text text-anchor="middle" x="82.8741" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">peak_basics</text>
    </a>
    </g>
    </g>
    <!-- peaks -->
    <g id="node2" class="node">
    <title>peaks</title>
    <g id="a_node2"><a xlink:href="#peaks" xlink:title="peaks">
    <ellipse fill="#98fb98" stroke="#000000" cx="82.8741" cy="-378" rx="38.1938" ry="18"/>
    <text text-anchor="middle" x="82.8741" y="-374.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks</text>
    </a>
    </g>
    </g>
    <!-- peak_basics&#45;&gt;peaks -->
    <g id="edge1" class="edge">
    <title>peak_basics&#45;&gt;peaks</title>
    <path fill="none" stroke="#000000" d="M82.8741,-431.8314C82.8741,-424.131 82.8741,-414.9743 82.8741,-406.4166"/>
    <polygon fill="#000000" stroke="#000000" points="86.3742,-406.4132 82.8741,-396.4133 79.3742,-406.4133 86.3742,-406.4132"/>
    </g>
    <!-- peaklets -->
    <g id="node3" class="node">
    <title>peaklets</title>
    <g id="a_node3"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="130.8741" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="130.8741" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklets -->
    <g id="edge2" class="edge">
    <title>peaks&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M64.9431,-361.5318C34.225,-331.279 -22.1948,-265.4292 9.8741,-216 24.5748,-193.3411 51.244,-180.1078 75.8105,-172.4205"/>
    <polygon fill="#000000" stroke="#000000" points="76.8095,-175.7751 85.4496,-169.6433 74.8715,-169.0488 76.8095,-175.7751"/>
    </g>
    <!-- peaklet_classification -->
    <g id="node4" class="node">
    <title>peaklet_classification</title>
    <g id="a_node4"><a xlink:href="#peaklet-classification" xlink:title="peaklet_classification">
    <ellipse fill="#d9ff66" stroke="#000000" cx="130.8741" cy="-234" rx="111.5806" ry="18"/>
    <text text-anchor="middle" x="130.8741" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklet_classification</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklet_classification -->
    <g id="edge3" class="edge">
    <title>peaks&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M85.135,-359.9931C87.8079,-341.5194 93.0472,-312.148 101.8741,-288 105.1655,-278.9955 109.732,-269.6408 114.2685,-261.2976"/>
    <polygon fill="#000000" stroke="#000000" points="117.435,-262.8082 119.3079,-252.3802 111.3408,-259.3642 117.435,-262.8082"/>
    </g>
    <!-- merged_s2s -->
    <g id="node5" class="node">
    <title>merged_s2s</title>
    <g id="a_node5"><a xlink:href="#merged-s2s" xlink:title="merged_s2s">
    <ellipse fill="#ccffcc" stroke="#000000" cx="177.8741" cy="-306" rx="66.8882" ry="18"/>
    <text text-anchor="middle" x="177.8741" y="-302.3" font-family="Times,serif" font-size="14.00" fill="#000000">merged_s2s</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;merged_s2s -->
    <g id="edge4" class="edge">
    <title>peaks&#45;&gt;merged_s2s</title>
    <path fill="none" stroke="#000000" d="M103.4877,-362.3771C116.2607,-352.6965 132.9012,-340.0847 147.2037,-329.2449"/>
    <polygon fill="#000000" stroke="#000000" points="149.4521,-331.9326 155.3077,-323.1029 145.2239,-326.3538 149.4521,-331.9326"/>
    </g>
    <!-- records -->
    <g id="node6" class="node">
    <title>records</title>
    <g id="a_node6"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="190.8741" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="190.8741" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge5" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M145.3984,-144.5708C152.7683,-135.7269 161.8542,-124.8239 169.962,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="172.7704,-117.1916 176.4835,-107.2687 167.3928,-112.7103 172.7704,-117.1916"/>
    </g>
    <!-- peaklet_classification&#45;&gt;peaklets -->
    <g id="edge10" class="edge">
    <title>peaklet_classification&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M130.8741,-215.8314C130.8741,-208.131 130.8741,-198.9743 130.8741,-190.4166"/>
    <polygon fill="#000000" stroke="#000000" points="134.3742,-190.4132 130.8741,-180.4133 127.3742,-190.4133 134.3742,-190.4132"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklets -->
    <g id="edge11" class="edge">
    <title>merged_s2s&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M211.789,-290.4273C226.985,-281.5104 243.3715,-268.7303 251.8741,-252 259.1231,-237.7363 260.5824,-229.4226 251.8741,-216 243.2031,-202.635 208.4936,-187.9245 178.4604,-177.2369"/>
    <polygon fill="#000000" stroke="#000000" points="179.5075,-173.8954 168.9126,-173.915 177.2072,-180.5067 179.5075,-173.8954"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklet_classification -->
    <g id="edge12" class="edge">
    <title>merged_s2s&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M166.2561,-288.2022C160.8177,-279.871 154.2271,-269.7748 148.2151,-260.565"/>
    <polygon fill="#000000" stroke="#000000" points="151.082,-258.5537 142.6849,-252.0931 145.2203,-262.3801 151.082,-258.5537"/>
    </g>
    <!-- raw_records -->
    <g id="node8" class="node">
    <title>raw_records</title>
    <g id="a_node8"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="324.8741" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="324.8741" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge7" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M217.991,-75.4297C237.3965,-65.0029 263.8202,-50.8051 285.5391,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="287.3727,-42.1233 294.525,-34.307 284.0594,-35.9571 287.3727,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node7" class="node">
    <title>lone_hits</title>
    <g id="a_node7"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="251.8741" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="251.8741" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge6" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M237.1077,-144.5708C229.6149,-135.7269 220.3777,-124.8239 212.1347,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="214.6392,-112.6361 205.5045,-107.2687 209.2983,-117.161 214.6392,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node9" class="node">
    <title>veto_regions</title>
    <g id="a_node9"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="324.8741" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="324.8741" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge8" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M324.8741,-71.8314C324.8741,-64.131 324.8741,-54.9743 324.8741,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="328.3742,-46.4132 324.8741,-36.4133 321.3742,-46.4133 328.3742,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node10" class="node">
    <title>pulse_counts</title>
    <g id="a_node10"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="484.8741" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="484.8741" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge9" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M449.7614,-74.1993C426.0249,-63.5179 394.4934,-49.3287 369.0527,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="370.185,-34.5519 359.6294,-33.6399 367.3124,-40.9353 370.185,-34.5519"/>
    </g>
    <!-- truth -->
    <g id="node11" class="node">
    <title>truth</title>
    <g id="a_node11"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="202.8741" cy="-450" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="202.8741" y="-446.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaks,)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>253</td>          <td>253</td>          <td>(peak_basics,)</td>          <td>Number of top PMTs</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>s1_max_rise_time</td>          <td>60</td>          <td>100</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &lt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_max_rise_time_post100</td>          <td>150</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &gt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_min_coincidence</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum tight coincidence necessary to make an S1</td>        </tr>        <tr>          <td>s2_merge_max_area</td>          <td>5000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Merge peaklet cluster only if area &lt; this [PE]</td>        </tr>        <tr>          <td>s2_merge_max_duration</td>          <td>15000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Do not merge peaklets at all if the result would be a peak longer than this [ns]</td>        </tr>        <tr>          <td>s2_merge_max_gap</td>          <td>3500</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Maximum separation between peaklets to allow merging [ns]</td>        </tr>        <tr>          <td>s2_min_pmts</td>          <td>4</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum number of PMTs contributing to an S2</td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



peaks
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `Peaks <https://github.com/XENONnT/straxen/blob/master/straxen/plugins/peaklet_processing.py>`_

Data kind: peaks


    Merge peaklets and merged S2s such that we obtain our peaks
    (replacing all peaklets that were later re-merged as S2s). As this
    step is computationally trivial, never save this plugin.
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the interval in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Width of one sample [ns]</td>        </tr>        <tr>          <td>channel</td>          <td>int16</td>          <td>Channel/PMT number</td>        </tr>        <tr>          <td>type</td>          <td>int8</td>          <td>Classification of the peak(let)</td>        </tr>        <tr>          <td>area</td>          <td>float32</td>          <td>Integral across channels [PE]</td>        </tr>        <tr>          <td>area_per_channel</td>          <td>('&lt;f4', (494,))</td>          <td>Integral per channel [PE]</td>        </tr>        <tr>          <td>n_hits</td>          <td>int32</td>          <td>Number of hits contributing at least one sample to the peak</td>        </tr>        <tr>          <td>data</td>          <td>('&lt;f4', (200,))</td>          <td>Waveform data in PE/sample (not PE/ns!)</td>        </tr>        <tr>          <td>width</td>          <td>('&lt;f4', (11,))</td>          <td>Peak widths in range of central area fraction [ns]</td>        </tr>        <tr>          <td>area_decile_from_midpoint</td>          <td>('&lt;f4', (11,))</td>          <td>Peak widths: time between nth and 5th area decile [ns]</td>        </tr>        <tr>          <td>saturated_channel</td>          <td>('i1', (494,))</td>          <td>Does the channel reach ADC saturation?</td>        </tr>        <tr>          <td>n_saturated_channels</td>          <td>int16</td>          <td>Total number of saturated channels</td>        </tr>        <tr>          <td>tight_coincidence</td>          <td>int16</td>          <td>Hits within tight range of mean</td>        </tr>        <tr>          <td>max_gap</td>          <td>int32</td>          <td>Largest gap between hits inside peak [ns]</td>        </tr>        <tr>          <td>max_goodness_of_split</td>          <td>float32</td>          <td>Maximum interior goodness of split</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="564pt" height="404pt"
     viewBox="0.00 0.00 564.37 404.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 400)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-400 560.3677,-400 560.3677,4 -4,4"/>
    <!-- peaks -->
    <g id="node1" class="node">
    <title>peaks</title>
    <g id="a_node1"><a xlink:href="#peaks" xlink:title="peaks">
    <ellipse fill="#98fb98" stroke="#000000" cx="82.8741" cy="-378" rx="38.1938" ry="18"/>
    <text text-anchor="middle" x="82.8741" y="-374.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaks</text>
    </a>
    </g>
    </g>
    <!-- peaklets -->
    <g id="node2" class="node">
    <title>peaklets</title>
    <g id="a_node2"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="130.8741" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="130.8741" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklets -->
    <g id="edge1" class="edge">
    <title>peaks&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M64.9431,-361.5318C34.225,-331.279 -22.1948,-265.4292 9.8741,-216 24.5748,-193.3411 51.244,-180.1078 75.8105,-172.4205"/>
    <polygon fill="#000000" stroke="#000000" points="76.8095,-175.7751 85.4496,-169.6433 74.8715,-169.0488 76.8095,-175.7751"/>
    </g>
    <!-- peaklet_classification -->
    <g id="node3" class="node">
    <title>peaklet_classification</title>
    <g id="a_node3"><a xlink:href="#peaklet-classification" xlink:title="peaklet_classification">
    <ellipse fill="#d9ff66" stroke="#000000" cx="130.8741" cy="-234" rx="111.5806" ry="18"/>
    <text text-anchor="middle" x="130.8741" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklet_classification</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;peaklet_classification -->
    <g id="edge2" class="edge">
    <title>peaks&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M85.135,-359.9931C87.8079,-341.5194 93.0472,-312.148 101.8741,-288 105.1655,-278.9955 109.732,-269.6408 114.2685,-261.2976"/>
    <polygon fill="#000000" stroke="#000000" points="117.435,-262.8082 119.3079,-252.3802 111.3408,-259.3642 117.435,-262.8082"/>
    </g>
    <!-- merged_s2s -->
    <g id="node4" class="node">
    <title>merged_s2s</title>
    <g id="a_node4"><a xlink:href="#merged-s2s" xlink:title="merged_s2s">
    <ellipse fill="#ccffcc" stroke="#000000" cx="177.8741" cy="-306" rx="66.8882" ry="18"/>
    <text text-anchor="middle" x="177.8741" y="-302.3" font-family="Times,serif" font-size="14.00" fill="#000000">merged_s2s</text>
    </a>
    </g>
    </g>
    <!-- peaks&#45;&gt;merged_s2s -->
    <g id="edge3" class="edge">
    <title>peaks&#45;&gt;merged_s2s</title>
    <path fill="none" stroke="#000000" d="M103.4877,-362.3771C116.2607,-352.6965 132.9012,-340.0847 147.2037,-329.2449"/>
    <polygon fill="#000000" stroke="#000000" points="149.4521,-331.9326 155.3077,-323.1029 145.2239,-326.3538 149.4521,-331.9326"/>
    </g>
    <!-- records -->
    <g id="node5" class="node">
    <title>records</title>
    <g id="a_node5"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="190.8741" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="190.8741" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge4" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M145.3984,-144.5708C152.7683,-135.7269 161.8542,-124.8239 169.962,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="172.7704,-117.1916 176.4835,-107.2687 167.3928,-112.7103 172.7704,-117.1916"/>
    </g>
    <!-- peaklet_classification&#45;&gt;peaklets -->
    <g id="edge9" class="edge">
    <title>peaklet_classification&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M130.8741,-215.8314C130.8741,-208.131 130.8741,-198.9743 130.8741,-190.4166"/>
    <polygon fill="#000000" stroke="#000000" points="134.3742,-190.4132 130.8741,-180.4133 127.3742,-190.4133 134.3742,-190.4132"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklets -->
    <g id="edge10" class="edge">
    <title>merged_s2s&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M211.789,-290.4273C226.985,-281.5104 243.3715,-268.7303 251.8741,-252 259.1231,-237.7363 260.5824,-229.4226 251.8741,-216 243.2031,-202.635 208.4936,-187.9245 178.4604,-177.2369"/>
    <polygon fill="#000000" stroke="#000000" points="179.5075,-173.8954 168.9126,-173.915 177.2072,-180.5067 179.5075,-173.8954"/>
    </g>
    <!-- merged_s2s&#45;&gt;peaklet_classification -->
    <g id="edge11" class="edge">
    <title>merged_s2s&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M166.2561,-288.2022C160.8177,-279.871 154.2271,-269.7748 148.2151,-260.565"/>
    <polygon fill="#000000" stroke="#000000" points="151.082,-258.5537 142.6849,-252.0931 145.2203,-262.3801 151.082,-258.5537"/>
    </g>
    <!-- raw_records -->
    <g id="node7" class="node">
    <title>raw_records</title>
    <g id="a_node7"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="324.8741" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="324.8741" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge6" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M217.991,-75.4297C237.3965,-65.0029 263.8202,-50.8051 285.5391,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="287.3727,-42.1233 294.525,-34.307 284.0594,-35.9571 287.3727,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node6" class="node">
    <title>lone_hits</title>
    <g id="a_node6"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="251.8741" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="251.8741" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge5" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M237.1077,-144.5708C229.6149,-135.7269 220.3777,-124.8239 212.1347,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="214.6392,-112.6361 205.5045,-107.2687 209.2983,-117.161 214.6392,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node8" class="node">
    <title>veto_regions</title>
    <g id="a_node8"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="324.8741" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="324.8741" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge7" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M324.8741,-71.8314C324.8741,-64.131 324.8741,-54.9743 324.8741,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="328.3742,-46.4132 324.8741,-36.4133 321.3742,-46.4133 328.3742,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node9" class="node">
    <title>pulse_counts</title>
    <g id="a_node9"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="484.8741" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="484.8741" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge8" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M449.7614,-74.1993C426.0249,-63.5179 394.4934,-49.3287 369.0527,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="370.185,-34.5519 359.6294,-33.6399 367.3124,-40.9353 370.185,-34.5519"/>
    </g>
    <!-- truth -->
    <g id="node10" class="node">
    <title>truth</title>
    <g id="a_node10"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="173.8741" cy="-378" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="173.8741" y="-374.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaks,)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>s1_max_rise_time</td>          <td>60</td>          <td>100</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &lt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_max_rise_time_post100</td>          <td>150</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &gt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_min_coincidence</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum tight coincidence necessary to make an S1</td>        </tr>        <tr>          <td>s2_merge_max_area</td>          <td>5000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Merge peaklet cluster only if area &lt; this [PE]</td>        </tr>        <tr>          <td>s2_merge_max_duration</td>          <td>15000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Do not merge peaklets at all if the result would be a peak longer than this [ns]</td>        </tr>        <tr>          <td>s2_merge_max_gap</td>          <td>3500</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Maximum separation between peaklets to allow merging [ns]</td>        </tr>        <tr>          <td>s2_min_pmts</td>          <td>4</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum number of PMTs contributing to an S2</td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



merged_s2s
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `MergedS2s <https://github.com/XENONnT/straxen/blob/master/straxen/plugins/peaklet_processing.py>`_

Data kind: merged_s2s


    Merge together peaklets if peak finding favours that they would
    form a single peak instead.
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the interval in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Width of one sample [ns]</td>        </tr>        <tr>          <td>channel</td>          <td>int16</td>          <td>Channel/PMT number</td>        </tr>        <tr>          <td>type</td>          <td>int8</td>          <td>Classification of the peak(let)</td>        </tr>        <tr>          <td>area</td>          <td>float32</td>          <td>Integral across channels [PE]</td>        </tr>        <tr>          <td>area_per_channel</td>          <td>('&lt;f4', (494,))</td>          <td>Integral per channel [PE]</td>        </tr>        <tr>          <td>n_hits</td>          <td>int32</td>          <td>Number of hits contributing at least one sample to the peak</td>        </tr>        <tr>          <td>data</td>          <td>('&lt;f4', (200,))</td>          <td>Waveform data in PE/sample (not PE/ns!)</td>        </tr>        <tr>          <td>width</td>          <td>('&lt;f4', (11,))</td>          <td>Peak widths in range of central area fraction [ns]</td>        </tr>        <tr>          <td>area_decile_from_midpoint</td>          <td>('&lt;f4', (11,))</td>          <td>Peak widths: time between nth and 5th area decile [ns]</td>        </tr>        <tr>          <td>saturated_channel</td>          <td>('i1', (494,))</td>          <td>Does the channel reach ADC saturation?</td>        </tr>        <tr>          <td>n_saturated_channels</td>          <td>int16</td>          <td>Total number of saturated channels</td>        </tr>        <tr>          <td>tight_coincidence</td>          <td>int16</td>          <td>Hits within tight range of mean</td>        </tr>        <tr>          <td>max_gap</td>          <td>int32</td>          <td>Largest gap between hits inside peak [ns]</td>        </tr>        <tr>          <td>max_goodness_of_split</td>          <td>float32</td>          <td>Maximum interior goodness of split</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="500pt" height="332pt"
     viewBox="0.00 0.00 500.44 332.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 328)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-328 496.4377,-328 496.4377,4 -4,4"/>
    <!-- merged_s2s -->
    <g id="node1" class="node">
    <title>merged_s2s</title>
    <g id="a_node1"><a xlink:href="#merged-s2s" xlink:title="merged_s2s">
    <ellipse fill="#ccffcc" stroke="#000000" cx="66.9441" cy="-306" rx="66.8882" ry="18"/>
    <text text-anchor="middle" x="66.9441" y="-302.3" font-family="Times,serif" font-size="14.00" fill="#000000">merged_s2s</text>
    </a>
    </g>
    </g>
    <!-- peaklets -->
    <g id="node2" class="node">
    <title>peaklets</title>
    <g id="a_node2"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="66.9441" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="66.9441" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- merged_s2s&#45;&gt;peaklets -->
    <g id="edge1" class="edge">
    <title>merged_s2s&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M44.1636,-288.8838C33.4175,-279.356 21.7087,-266.4993 15.9441,-252 10.0329,-237.132 10.0329,-230.868 15.9441,-216 20.5132,-204.5077 28.8167,-194.0472 37.4152,-185.4585"/>
    <polygon fill="#000000" stroke="#000000" points="40.0399,-187.7963 44.961,-178.4137 35.2629,-182.6796 40.0399,-187.7963"/>
    </g>
    <!-- peaklet_classification -->
    <g id="node3" class="node">
    <title>peaklet_classification</title>
    <g id="a_node3"><a xlink:href="#peaklet-classification" xlink:title="peaklet_classification">
    <ellipse fill="#d9ff66" stroke="#000000" cx="136.9441" cy="-234" rx="111.5806" ry="18"/>
    <text text-anchor="middle" x="136.9441" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklet_classification</text>
    </a>
    </g>
    </g>
    <!-- merged_s2s&#45;&gt;peaklet_classification -->
    <g id="edge2" class="edge">
    <title>merged_s2s&#45;&gt;peaklet_classification</title>
    <path fill="none" stroke="#000000" d="M83.8891,-288.5708C92.3818,-279.8355 102.8275,-269.0914 112.1977,-259.4534"/>
    <polygon fill="#000000" stroke="#000000" points="114.9627,-261.6304 119.424,-252.0206 109.9437,-256.7508 114.9627,-261.6304"/>
    </g>
    <!-- records -->
    <g id="node4" class="node">
    <title>records</title>
    <g id="a_node4"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="126.9441" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="126.9441" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge3" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M81.4684,-144.5708C88.8383,-135.7269 97.9241,-124.8239 106.032,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="108.8404,-117.1916 112.5535,-107.2687 103.4628,-112.7103 108.8404,-117.1916"/>
    </g>
    <!-- peaklet_classification&#45;&gt;peaklets -->
    <g id="edge8" class="edge">
    <title>peaklet_classification&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M119.6407,-216.2022C110.8653,-207.1761 100.0757,-196.0783 90.55,-186.2804"/>
    <polygon fill="#000000" stroke="#000000" points="93.0467,-183.8274 83.5664,-179.0972 88.0277,-188.707 93.0467,-183.8274"/>
    </g>
    <!-- raw_records -->
    <g id="node6" class="node">
    <title>raw_records</title>
    <g id="a_node6"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="260.9441" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="260.9441" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge5" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M154.061,-75.4297C173.4665,-65.0029 199.8902,-50.8051 221.6091,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="223.4426,-42.1233 230.595,-34.307 220.1294,-35.9571 223.4426,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node5" class="node">
    <title>lone_hits</title>
    <g id="a_node5"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="187.9441" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="187.9441" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge4" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M173.1777,-144.5708C165.6849,-135.7269 156.4476,-124.8239 148.2046,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="150.7091,-112.6361 141.5745,-107.2687 145.3682,-117.161 150.7091,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node7" class="node">
    <title>veto_regions</title>
    <g id="a_node7"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="260.9441" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="260.9441" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge6" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M260.9441,-71.8314C260.9441,-64.131 260.9441,-54.9743 260.9441,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="264.4442,-46.4132 260.9441,-36.4133 257.4442,-46.4133 264.4442,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node8" class="node">
    <title>pulse_counts</title>
    <g id="a_node8"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="420.9441" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="420.9441" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge7" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M385.8314,-74.1993C362.0949,-63.5179 330.5633,-49.3287 305.1226,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="306.2549,-34.5519 295.6994,-33.6399 303.3824,-40.9353 306.2549,-34.5519"/>
    </g>
    <!-- truth -->
    <g id="node9" class="node">
    <title>truth</title>
    <g id="a_node9"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="185.9441" cy="-306" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="185.9441" y="-302.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>s1_max_rise_time</td>          <td>60</td>          <td>100</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &lt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_max_rise_time_post100</td>          <td>150</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &gt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_min_coincidence</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum tight coincidence necessary to make an S1</td>        </tr>        <tr>          <td>s2_merge_max_area</td>          <td>5000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Merge peaklet cluster only if area &lt; this [PE]</td>        </tr>        <tr>          <td>s2_merge_max_duration</td>          <td>15000</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Do not merge peaklets at all if the result would be a peak longer than this [ns]</td>        </tr>        <tr>          <td>s2_merge_max_gap</td>          <td>3500</td>          <td>&lt;OMITTED&gt;</td>          <td>(merged_s2s,)</td>          <td>Maximum separation between peaklets to allow merging [ns]</td>        </tr>        <tr>          <td>s2_min_pmts</td>          <td>4</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum number of PMTs contributing to an S2</td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



peaklet_classification
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `PeakletClassification <https://github.com/XENONnT/straxen/blob/master/straxen/plugins/peaklet_processing.py>`_

Data kind: peaklets

Classify peaklets as unknown, S1, or S2.


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the interval in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Width of one sample [ns]</td>        </tr>        <tr>          <td>channel</td>          <td>int16</td>          <td>Channel/PMT number</td>        </tr>        <tr>          <td>type</td>          <td>int8</td>          <td>Classification of the peak(let)</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="545pt" height="260pt"
     viewBox="0.00 0.00 545.28 260.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 256)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-256 541.2837,-256 541.2837,4 -4,4"/>
    <!-- peaklet_classification -->
    <g id="node1" class="node">
    <title>peaklet_classification</title>
    <g id="a_node1"><a xlink:href="#peaklet-classification" xlink:title="peaklet_classification">
    <ellipse fill="#d9ff66" stroke="#000000" cx="111.7901" cy="-234" rx="111.5806" ry="18"/>
    <text text-anchor="middle" x="111.7901" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklet_classification</text>
    </a>
    </g>
    </g>
    <!-- peaklets -->
    <g id="node2" class="node">
    <title>peaklets</title>
    <g id="a_node2"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="111.7901" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="111.7901" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- peaklet_classification&#45;&gt;peaklets -->
    <g id="edge1" class="edge">
    <title>peaklet_classification&#45;&gt;peaklets</title>
    <path fill="none" stroke="#000000" d="M111.7901,-215.8314C111.7901,-208.131 111.7901,-198.9743 111.7901,-190.4166"/>
    <polygon fill="#000000" stroke="#000000" points="115.2902,-190.4132 111.7901,-180.4133 108.2902,-190.4133 115.2902,-190.4132"/>
    </g>
    <!-- records -->
    <g id="node3" class="node">
    <title>records</title>
    <g id="a_node3"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="171.7901" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="171.7901" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge2" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M126.3144,-144.5708C133.6843,-135.7269 142.7702,-124.8239 150.878,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="153.6864,-117.1916 157.3995,-107.2687 148.3088,-112.7103 153.6864,-117.1916"/>
    </g>
    <!-- raw_records -->
    <g id="node5" class="node">
    <title>raw_records</title>
    <g id="a_node5"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="305.7901" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="305.7901" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge4" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M198.907,-75.4297C218.3125,-65.0029 244.7362,-50.8051 266.4551,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="268.2887,-42.1233 275.441,-34.307 264.9754,-35.9571 268.2887,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node4" class="node">
    <title>lone_hits</title>
    <g id="a_node4"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="232.7901" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="232.7901" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge3" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M218.0237,-144.5708C210.5309,-135.7269 201.2937,-124.8239 193.0507,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="195.5552,-112.6361 186.4205,-107.2687 190.2142,-117.161 195.5552,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node6" class="node">
    <title>veto_regions</title>
    <g id="a_node6"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="305.7901" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="305.7901" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge5" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M305.7901,-71.8314C305.7901,-64.131 305.7901,-54.9743 305.7901,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="309.2902,-46.4132 305.7901,-36.4133 302.2902,-46.4133 309.2902,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node7" class="node">
    <title>pulse_counts</title>
    <g id="a_node7"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="465.7901" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="465.7901" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge6" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M430.6774,-74.1993C406.9409,-63.5179 375.4094,-49.3287 349.9687,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="351.101,-34.5519 340.5454,-33.6399 348.2284,-40.9353 351.101,-34.5519"/>
    </g>
    <!-- truth -->
    <g id="node8" class="node">
    <title>truth</title>
    <g id="a_node8"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="275.7901" cy="-234" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="275.7901" y="-230.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>s1_max_rise_time</td>          <td>60</td>          <td>100</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &lt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_max_rise_time_post100</td>          <td>150</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Maximum S1 rise time for &gt; 100 PE [ns]</td>        </tr>        <tr>          <td>s1_min_coincidence</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum tight coincidence necessary to make an S1</td>        </tr>        <tr>          <td>s2_min_pmts</td>          <td>4</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklet_classification,)</td>          <td>Minimum number of PMTs contributing to an S2</td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



peaklets
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `Peaklets <https://github.com/XENONnT/straxen/blob/master/straxen/plugins/peaklet_processing.py>`_

Data kind: peaklets


    Split records into:
        -peaklets
        -lone_hits

    Peaklets are very aggressively split peaks such that we are able
    to find S1-S2s even if they are close to each other. (S2) Peaks
    that are split into too many peaklets will be merged later on.

    To get Peaklets from records apply/do:
        1. Hit finding
        2. Peak finding
        3. Peak splitting using the natural breaks algorithm
        4. Compute the digital sum waveform

    Lone hits are all hits which are outside of any peak. The area of
    lone_hits includes the left and right hit extension, except the
    extension overlaps with any peaks or other hits.
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the interval in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Width of one sample [ns]</td>        </tr>        <tr>          <td>channel</td>          <td>int16</td>          <td>Channel/PMT number</td>        </tr>        <tr>          <td>type</td>          <td>int8</td>          <td>Classification of the peak(let)</td>        </tr>        <tr>          <td>area</td>          <td>float32</td>          <td>Integral across channels [PE]</td>        </tr>        <tr>          <td>area_per_channel</td>          <td>('&lt;f4', (494,))</td>          <td>Integral per channel [PE]</td>        </tr>        <tr>          <td>n_hits</td>          <td>int32</td>          <td>Number of hits contributing at least one sample to the peak</td>        </tr>        <tr>          <td>data</td>          <td>('&lt;f4', (200,))</td>          <td>Waveform data in PE/sample (not PE/ns!)</td>        </tr>        <tr>          <td>width</td>          <td>('&lt;f4', (11,))</td>          <td>Peak widths in range of central area fraction [ns]</td>        </tr>        <tr>          <td>area_decile_from_midpoint</td>          <td>('&lt;f4', (11,))</td>          <td>Peak widths: time between nth and 5th area decile [ns]</td>        </tr>        <tr>          <td>saturated_channel</td>          <td>('i1', (494,))</td>          <td>Does the channel reach ADC saturation?</td>        </tr>        <tr>          <td>n_saturated_channels</td>          <td>int16</td>          <td>Total number of saturated channels</td>        </tr>        <tr>          <td>tight_coincidence</td>          <td>int16</td>          <td>Hits within tight range of mean</td>        </tr>        <tr>          <td>max_gap</td>          <td>int32</td>          <td>Largest gap between hits inside peak [ns]</td>        </tr>        <tr>          <td>max_goodness_of_split</td>          <td>float32</td>          <td>Maximum interior goodness of split</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="484pt" height="188pt"
     viewBox="0.00 0.00 483.54 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-184 479.5392,-184 479.5392,4 -4,4"/>
    <!-- peaklets -->
    <g id="node1" class="node">
    <title>peaklets</title>
    <g id="a_node1"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="50.0456" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="50.0456" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- records -->
    <g id="node2" class="node">
    <title>records</title>
    <g id="a_node2"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="110.0456" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="110.0456" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge1" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M64.5699,-144.5708C71.9398,-135.7269 81.0256,-124.8239 89.1335,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="91.9419,-117.1916 95.655,-107.2687 86.5643,-112.7103 91.9419,-117.1916"/>
    </g>
    <!-- raw_records -->
    <g id="node4" class="node">
    <title>raw_records</title>
    <g id="a_node4"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="244.0456" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="244.0456" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge3" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M137.1625,-75.4297C156.568,-65.0029 182.9917,-50.8051 204.7106,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="206.5441,-42.1233 213.6965,-34.307 203.2309,-35.9571 206.5441,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node3" class="node">
    <title>lone_hits</title>
    <g id="a_node3"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="171.0456" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="171.0456" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge2" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M156.2792,-144.5708C148.7864,-135.7269 139.5491,-124.8239 131.3061,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="133.8106,-112.6361 124.676,-107.2687 128.4697,-117.161 133.8106,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node5" class="node">
    <title>veto_regions</title>
    <g id="a_node5"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="244.0456" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="244.0456" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge4" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M244.0456,-71.8314C244.0456,-64.131 244.0456,-54.9743 244.0456,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="247.5457,-46.4132 244.0456,-36.4133 240.5457,-46.4133 247.5457,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node6" class="node">
    <title>pulse_counts</title>
    <g id="a_node6"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="404.0456" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="404.0456" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge5" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M368.9329,-74.1993C345.1964,-63.5179 313.6648,-49.3287 288.2241,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="289.3564,-34.5519 278.8009,-33.6399 286.4838,-40.9353 289.3564,-34.5519"/>
    </g>
    <!-- truth -->
    <g id="node7" class="node">
    <title>truth</title>
    <g id="a_node7"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="276.0456" cy="-162" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="276.0456" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



lone_hits
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `Peaklets <https://github.com/XENONnT/straxen/blob/master/straxen/plugins/peaklet_processing.py>`_

Data kind: lone_hits


    Split records into:
        -peaklets
        -lone_hits

    Peaklets are very aggressively split peaks such that we are able
    to find S1-S2s even if they are close to each other. (S2) Peaks
    that are split into too many peaklets will be merged later on.

    To get Peaklets from records apply/do:
        1. Hit finding
        2. Peak finding
        3. Peak splitting using the natural breaks algorithm
        4. Compute the digital sum waveform

    Lone hits are all hits which are outside of any peak. The area of
    lone_hits includes the left and right hit extension, except the
    extension overlaps with any peaks or other hits.
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the interval in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Width of one sample [ns]</td>        </tr>        <tr>          <td>channel</td>          <td>int16</td>          <td>Channel/PMT number</td>        </tr>        <tr>          <td>area</td>          <td>float32</td>          <td>Integral [ADC x samples]</td>        </tr>        <tr>          <td>left</td>          <td>int16</td>          <td>Index of sample in record in which hit starts</td>        </tr>        <tr>          <td>right</td>          <td>int16</td>          <td>Index of first sample in record just beyond hit (exclusive bound)</td>        </tr>        <tr>          <td>left_integration</td>          <td>int16</td>          <td>For lone hits, index of sample in record where integration starts</td>        </tr>        <tr>          <td>right_integration</td>          <td>int16</td>          <td>For lone hits, index of first sample beyond integration region</td>        </tr>        <tr>          <td>record_i</td>          <td>int32</td>          <td>Internal (temporary) index of fragment in which hit was found</td>        </tr>        <tr>          <td>threshold</td>          <td>float32</td>          <td>ADC threshold applied in order to find hits</td>        </tr>        <tr>          <td>height</td>          <td>float32</td>          <td>Maximum amplitude above baseline [ADC counts]</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="484pt" height="188pt"
     viewBox="0.00 0.00 483.54 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-184 479.5392,-184 479.5392,4 -4,4"/>
    <!-- peaklets -->
    <g id="node1" class="node">
    <title>peaklets</title>
    <g id="a_node1"><a xlink:href="#peaklets" xlink:title="peaklets">
    <ellipse fill="#d9ff66" stroke="#000000" cx="50.0456" cy="-162" rx="50.0912" ry="18"/>
    <text text-anchor="middle" x="50.0456" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">peaklets</text>
    </a>
    </g>
    </g>
    <!-- records -->
    <g id="node2" class="node">
    <title>records</title>
    <g id="a_node2"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="110.0456" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="110.0456" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- peaklets&#45;&gt;records -->
    <g id="edge1" class="edge">
    <title>peaklets&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M64.5699,-144.5708C71.9398,-135.7269 81.0256,-124.8239 89.1335,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="91.9419,-117.1916 95.655,-107.2687 86.5643,-112.7103 91.9419,-117.1916"/>
    </g>
    <!-- raw_records -->
    <g id="node4" class="node">
    <title>raw_records</title>
    <g id="a_node4"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="244.0456" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="244.0456" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge3" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M137.1625,-75.4297C156.568,-65.0029 182.9917,-50.8051 204.7106,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="206.5441,-42.1233 213.6965,-34.307 203.2309,-35.9571 206.5441,-42.1233"/>
    </g>
    <!-- lone_hits -->
    <g id="node3" class="node">
    <title>lone_hits</title>
    <g id="a_node3"><a xlink:href="#lone-hits" xlink:title="lone_hits">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="171.0456" cy="-162" rx="52.7911" ry="18"/>
    <text text-anchor="middle" x="171.0456" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">lone_hits</text>
    </a>
    </g>
    </g>
    <!-- lone_hits&#45;&gt;records -->
    <g id="edge2" class="edge">
    <title>lone_hits&#45;&gt;records</title>
    <path fill="none" stroke="#000000" d="M156.2792,-144.5708C148.7864,-135.7269 139.5491,-124.8239 131.3061,-115.0945"/>
    <polygon fill="#000000" stroke="#000000" points="133.8106,-112.6361 124.676,-107.2687 128.4697,-117.161 133.8106,-112.6361"/>
    </g>
    <!-- veto_regions -->
    <g id="node5" class="node">
    <title>veto_regions</title>
    <g id="a_node5"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="244.0456" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="244.0456" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge4" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M244.0456,-71.8314C244.0456,-64.131 244.0456,-54.9743 244.0456,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="247.5457,-46.4132 244.0456,-36.4133 240.5457,-46.4133 247.5457,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node6" class="node">
    <title>pulse_counts</title>
    <g id="a_node6"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="404.0456" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="404.0456" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge5" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M368.9329,-74.1993C345.1964,-63.5179 313.6648,-49.3287 288.2241,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="289.3564,-34.5519 278.8009,-33.6399 286.4838,-40.9353 289.3564,-34.5519"/>
    </g>
    <!-- truth -->
    <g id="node7" class="node">
    <title>truth</title>
    <g id="a_node7"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="276.0456" cy="-162" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="276.0456" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>diagnose_sorting</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Enable runtime checks for sorting and disjointness</td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>&lt;OMITTED&gt;</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(peaklets, lone_hits)</td>          <td>PMT gain model. Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(peaklets, lone_hits)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>peak_left_extension</td>          <td>30</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns left of hits in peaks</td>        </tr>        <tr>          <td>peak_min_pmts</td>          <td>2</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of contributing PMTs needed to define a peak</td>        </tr>        <tr>          <td>peak_right_extension</td>          <td>200</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Include this many ns right of hits in peaks</td>        </tr>        <tr>          <td>peak_split_filter_wing_width</td>          <td>70</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Wing width of moving average filter for low-split natural breaks</td>        </tr>        <tr>          <td>peak_split_gof_threshold</td>          <td>(None, ((0.5, 1), (4, 0.4)), ((2, 1), (4.5, 0.4)))</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Natural breaks goodness of fit/split threshold to split a peak. Specify as tuples of (log10(area), threshold).</td>        </tr>        <tr>          <td>peak_split_iterations</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of recursive peak splits to do.</td>        </tr>        <tr>          <td>peak_split_min_area</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum area to evaluate natural breaks criterion. Smaller peaks are not split.</td>        </tr>        <tr>          <td>peaklet_gap_threshold</td>          <td>350</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>No hits for this many ns triggers a new peak</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>saturation_correction_on</td>          <td>True</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>On off switch for saturation correction</td>        </tr>        <tr>          <td>saturation_min_reference_length</td>          <td>20</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Minimum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>saturation_reference_length</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Maximum number of reference sample used to correct saturated samples</td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>tight_coincidence_window_left</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range left of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>tight_coincidence_window_right</td>          <td>50</td>          <td>&lt;OMITTED&gt;</td>          <td>(peaklets, lone_hits)</td>          <td>Time range right of peak center to call a hit a tight coincidence (ns)</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



records
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `PulseProcessing <https://github.com/XENONnT/straxen/blob/master/straxen/plugins/pulse_processing.py>`_

Data kind: records


    1. Split raw_records into:
     - (tpc) records
     - aqmon_records
     - pulse_counts

    For TPC records, apply basic processing:
        1. Flip, baseline, and integrate the waveform
        2. Apply software HE veto after high-energy peaks.
        3. Find hits, apply linear filter, and zero outside hits.
    
    pulse_counts holds some average information for the individual PMT
    channels for each chunk of raw_records. This includes e.g.
    number of recorded pulses, lone_pulses (pulses which do not
    overlap with any other pulse), or mean values of baseline and
    baseline rms channel.
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the interval in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Width of one sample [ns]</td>        </tr>        <tr>          <td>channel</td>          <td>int16</td>          <td>Channel/PMT number</td>        </tr>        <tr>          <td>pulse_length</td>          <td>int32</td>          <td>Length of pulse to which the record belongs (without zero-padding)</td>        </tr>        <tr>          <td>record_i</td>          <td>int16</td>          <td>Fragment number in the pulse</td>        </tr>        <tr>          <td>area</td>          <td>int32</td>          <td>Integral in ADC counts x samples</td>        </tr>        <tr>          <td>reduction_level</td>          <td>uint8</td>          <td>Level of data reduction applied (strax.ReductionLevel enum)</td>        </tr>        <tr>          <td>baseline</td>          <td>float32</td>          <td>Baseline in ADC counts. data = int(baseline) - data_orig</td>        </tr>        <tr>          <td>baseline_rms</td>          <td>float32</td>          <td>Baseline RMS in ADC counts. data = baseline - data_orig</td>        </tr>        <tr>          <td>amplitude_bit_shift</td>          <td>int16</td>          <td>Multiply data by 2**(this number). Baseline is unaffected.</td>        </tr>        <tr>          <td>data</td>          <td>('&lt;i2', (110,))</td>          <td>Waveform data in raw counts above integer part of baseline</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="507pt" height="116pt"
     viewBox="0.00 0.00 506.59 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-112 502.5928,-112 502.5928,4 -4,4"/>
    <!-- records -->
    <g id="node1" class="node">
    <title>records</title>
    <g id="a_node1"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="46.1459" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="46.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- raw_records -->
    <g id="node2" class="node">
    <title>raw_records</title>
    <g id="a_node2"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="180.1459" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="180.1459" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge1" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M73.2628,-75.4297C92.6683,-65.0029 119.092,-50.8051 140.8109,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="142.6445,-42.1233 149.7968,-34.307 139.3312,-35.9571 142.6445,-42.1233"/>
    </g>
    <!-- veto_regions -->
    <g id="node3" class="node">
    <title>veto_regions</title>
    <g id="a_node3"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="180.1459" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="180.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge2" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M180.1459,-71.8314C180.1459,-64.131 180.1459,-54.9743 180.1459,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="183.646,-46.4132 180.1459,-36.4133 176.646,-46.4133 183.646,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node4" class="node">
    <title>pulse_counts</title>
    <g id="a_node4"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="340.1459" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="340.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge3" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M305.0332,-74.1993C281.2967,-63.5179 249.7652,-49.3287 224.3245,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="225.4568,-34.5519 214.9013,-33.6399 222.5842,-40.9353 225.4568,-34.5519"/>
    </g>
    <!-- truth -->
    <g id="node5" class="node">
    <title>truth</title>
    <g id="a_node5"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="464.1459" cy="-90" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="464.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



veto_regions
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `PulseProcessing <https://github.com/XENONnT/straxen/blob/master/straxen/plugins/pulse_processing.py>`_

Data kind: veto_regions


    1. Split raw_records into:
     - (tpc) records
     - aqmon_records
     - pulse_counts

    For TPC records, apply basic processing:
        1. Flip, baseline, and integrate the waveform
        2. Apply software HE veto after high-energy peaks.
        3. Find hits, apply linear filter, and zero outside hits.
    
    pulse_counts holds some average information for the individual PMT
    channels for each chunk of raw_records. This includes e.g.
    number of recorded pulses, lone_pulses (pulses which do not
    overlap with any other pulse), or mean values of baseline and
    baseline rms channel.
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the interval in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Width of one sample [ns]</td>        </tr>        <tr>          <td>channel</td>          <td>int16</td>          <td>Channel/PMT number</td>        </tr>        <tr>          <td>area</td>          <td>float32</td>          <td>Integral [ADC x samples]</td>        </tr>        <tr>          <td>left</td>          <td>int16</td>          <td>Index of sample in record in which hit starts</td>        </tr>        <tr>          <td>right</td>          <td>int16</td>          <td>Index of first sample in record just beyond hit (exclusive bound)</td>        </tr>        <tr>          <td>left_integration</td>          <td>int16</td>          <td>For lone hits, index of sample in record where integration starts</td>        </tr>        <tr>          <td>right_integration</td>          <td>int16</td>          <td>For lone hits, index of first sample beyond integration region</td>        </tr>        <tr>          <td>record_i</td>          <td>int32</td>          <td>Internal (temporary) index of fragment in which hit was found</td>        </tr>        <tr>          <td>threshold</td>          <td>float32</td>          <td>ADC threshold applied in order to find hits</td>        </tr>        <tr>          <td>height</td>          <td>float32</td>          <td>Maximum amplitude above baseline [ADC counts]</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="507pt" height="116pt"
     viewBox="0.00 0.00 506.59 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-112 502.5928,-112 502.5928,4 -4,4"/>
    <!-- records -->
    <g id="node1" class="node">
    <title>records</title>
    <g id="a_node1"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="46.1459" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="46.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- raw_records -->
    <g id="node2" class="node">
    <title>raw_records</title>
    <g id="a_node2"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="180.1459" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="180.1459" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge1" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M73.2628,-75.4297C92.6683,-65.0029 119.092,-50.8051 140.8109,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="142.6445,-42.1233 149.7968,-34.307 139.3312,-35.9571 142.6445,-42.1233"/>
    </g>
    <!-- veto_regions -->
    <g id="node3" class="node">
    <title>veto_regions</title>
    <g id="a_node3"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="180.1459" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="180.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge2" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M180.1459,-71.8314C180.1459,-64.131 180.1459,-54.9743 180.1459,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="183.646,-46.4132 180.1459,-36.4133 176.646,-46.4133 183.646,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node4" class="node">
    <title>pulse_counts</title>
    <g id="a_node4"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="340.1459" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="340.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge3" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M305.0332,-74.1993C281.2967,-63.5179 249.7652,-49.3287 224.3245,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="225.4568,-34.5519 214.9013,-33.6399 222.5842,-40.9353 225.4568,-34.5519"/>
    </g>
    <!-- truth -->
    <g id="node5" class="node">
    <title>truth</title>
    <g id="a_node5"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="464.1459" cy="-90" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="464.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



pulse_counts
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `PulseProcessing <https://github.com/XENONnT/straxen/blob/master/straxen/plugins/pulse_processing.py>`_

Data kind: pulse_counts


    1. Split raw_records into:
     - (tpc) records
     - aqmon_records
     - pulse_counts

    For TPC records, apply basic processing:
        1. Flip, baseline, and integrate the waveform
        2. Apply software HE veto after high-energy peaks.
        3. Find hits, apply linear filter, and zero outside hits.
    
    pulse_counts holds some average information for the individual PMT
    channels for each chunk of raw_records. This includes e.g.
    number of recorded pulses, lone_pulses (pulses which do not
    overlap with any other pulse), or mean values of baseline and
    baseline rms channel.
    


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time of the chunk</td>        </tr>        <tr>          <td>endtime</td>          <td>int64</td>          <td>End time of the chunk</td>        </tr>        <tr>          <td>pulse_count</td>          <td>('&lt;i8', (494,))</td>          <td>Number of pulses</td>        </tr>        <tr>          <td>lone_pulse_count</td>          <td>('&lt;i8', (494,))</td>          <td>Number of lone pulses</td>        </tr>        <tr>          <td>pulse_area</td>          <td>('&lt;i8', (494,))</td>          <td>Integral of all pulses in ADC_count x samples</td>        </tr>        <tr>          <td>lone_pulse_area</td>          <td>('&lt;i8', (494,))</td>          <td>Integral of lone pulses in ADC_count x samples</td>        </tr>        <tr>          <td>baseline_mean</td>          <td>('&lt;i2', (494,))</td>          <td>Average baseline</td>        </tr>        <tr>          <td>baseline_rms_mean</td>          <td>('&lt;f4', (494,))</td>          <td>Average baseline rms</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="507pt" height="116pt"
     viewBox="0.00 0.00 506.59 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-112 502.5928,-112 502.5928,4 -4,4"/>
    <!-- records -->
    <g id="node1" class="node">
    <title>records</title>
    <g id="a_node1"><a xlink:href="#records" xlink:title="records">
    <ellipse fill="#ffa500" stroke="#000000" cx="46.1459" cy="-90" rx="46.2923" ry="18"/>
    <text text-anchor="middle" x="46.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">records</text>
    </a>
    </g>
    </g>
    <!-- raw_records -->
    <g id="node2" class="node">
    <title>raw_records</title>
    <g id="a_node2"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="180.1459" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="180.1459" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- records&#45;&gt;raw_records -->
    <g id="edge1" class="edge">
    <title>records&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M73.2628,-75.4297C92.6683,-65.0029 119.092,-50.8051 140.8109,-39.1352"/>
    <polygon fill="#000000" stroke="#000000" points="142.6445,-42.1233 149.7968,-34.307 139.3312,-35.9571 142.6445,-42.1233"/>
    </g>
    <!-- veto_regions -->
    <g id="node3" class="node">
    <title>veto_regions</title>
    <g id="a_node3"><a xlink:href="#veto-regions" xlink:title="veto_regions">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="180.1459" cy="-90" rx="70.3881" ry="18"/>
    <text text-anchor="middle" x="180.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">veto_regions</text>
    </a>
    </g>
    </g>
    <!-- veto_regions&#45;&gt;raw_records -->
    <g id="edge2" class="edge">
    <title>veto_regions&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M180.1459,-71.8314C180.1459,-64.131 180.1459,-54.9743 180.1459,-46.4166"/>
    <polygon fill="#000000" stroke="#000000" points="183.646,-46.4132 180.1459,-36.4133 176.646,-46.4133 183.646,-46.4132"/>
    </g>
    <!-- pulse_counts -->
    <g id="node4" class="node">
    <title>pulse_counts</title>
    <g id="a_node4"><a xlink:href="#pulse-counts" xlink:title="pulse_counts">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="340.1459" cy="-90" rx="71.4873" ry="18"/>
    <text text-anchor="middle" x="340.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">pulse_counts</text>
    </a>
    </g>
    </g>
    <!-- pulse_counts&#45;&gt;raw_records -->
    <g id="edge3" class="edge">
    <title>pulse_counts&#45;&gt;raw_records</title>
    <path fill="none" stroke="#000000" d="M305.0332,-74.1993C281.2967,-63.5179 249.7652,-49.3287 224.3245,-37.8804"/>
    <polygon fill="#000000" stroke="#000000" points="225.4568,-34.5519 214.9013,-33.6399 222.5842,-40.9353 225.4568,-34.5519"/>
    </g>
    <!-- truth -->
    <g id="node5" class="node">
    <title>truth</title>
    <g id="a_node5"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="464.1459" cy="-90" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="464.1459" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>allow_sloppy_chunking</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Use a default baseline for incorrectly chunked fragments. This is a kludge for improperly converted XENON1T data.</td>        </tr>        <tr>          <td>baseline_samples</td>          <td>40</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of samples to use at the start of the pulse to determine the baseline</td>        </tr>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>check_raw_record_overlaps</td>          <td>True</td>          <td>False</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Crash if any of the pulses in raw_records overlap with others in the same channel</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>hev_gain_model</td>          <td>(disabled, None)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>PMT gain model used in the software high-energy veto.Specify as (model_type, model_config)</td>        </tr>        <tr>          <td>hit_min_amplitude</td>          <td>pmt_commissioning_initial</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum hit amplitude in ADC counts above baseline. See straxen.hit_min_amplitude for options.</td>        </tr>        <tr>          <td>max_veto_value</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Optionally pass a HE peak that exceeds this absolute area. (if performing a hard veto, can keep a few statistics.)</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Number of TPC PMTs</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>pmt_pulse_filter</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Linear filter to apply to pulses, will be normalized.</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>save_outside_hits</td>          <td>(3, 20)</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Save (left, right) samples besides hits; cut the rest</td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>tail_veto_duration</td>          <td>3000000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time in ns to veto after large peaks</td>        </tr>        <tr>          <td>tail_veto_pass_extend</td>          <td>3</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Extend pass veto by this many samples (tail_veto_resolution!)</td>        </tr>        <tr>          <td>tail_veto_pass_fraction</td>          <td>0.05</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Pass veto if maximum amplitude above max * fraction</td>        </tr>        <tr>          <td>tail_veto_resolution</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Time resolution in ns for pass-veto waveform summation</td>        </tr>        <tr>          <td>tail_veto_threshold</td>          <td>0</td>          <td>&lt;OMITTED&gt;</td>          <td>(records, veto_regions, pulse_counts)</td>          <td>Minimum peakarea in PE to trigger tail veto.Set to None, 0 or False to disable veto.</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



raw_records
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `RawRecordsFromFaxNT <https://github.com/XENONnT/wfsim/blob/master/wfsim/strax_interface.py>`_

Data kind: raw_records

(no plugin description)


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the interval in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Width of one sample [ns]</td>        </tr>        <tr>          <td>channel</td>          <td>int16</td>          <td>Channel/PMT number</td>        </tr>        <tr>          <td>pulse_length</td>          <td>int32</td>          <td>Length of pulse to which the record belongs (without zero-padding)</td>        </tr>        <tr>          <td>record_i</td>          <td>int16</td>          <td>Fragment number in the pulse</td>        </tr>        <tr>          <td>baseline</td>          <td>int16</td>          <td>Baseline determined by the digitizer (if this is supported)</td>        </tr>        <tr>          <td>data</td>          <td>('&lt;i2', (110,))</td>          <td>Waveform data in raw ADC counts</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="460pt" height="44pt"
     viewBox="0.00 0.00 460.34 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-40 456.3408,-40 456.3408,4 -4,4"/>
    <!-- raw_records -->
    <g id="node1" class="node">
    <title>raw_records</title>
    <g id="a_node1"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="68.8939" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="68.8939" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- raw_records_aqmon -->
    <g id="node2" class="node">
    <title>raw_records_aqmon</title>
    <g id="a_node2"><a xlink:href="#raw-records-aqmon" xlink:title="raw_records_aqmon">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="260.8939" cy="-18" rx="104.7816" ry="18"/>
    <text text-anchor="middle" x="260.8939" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records_aqmon</text>
    </a>
    </g>
    </g>
    <!-- truth -->
    <g id="node3" class="node">
    <title>truth</title>
    <g id="a_node3"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="417.8939" cy="-18" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="417.8939" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



raw_records_aqmon
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `RawRecordsFromFaxNT <https://github.com/XENONnT/wfsim/blob/master/wfsim/strax_interface.py>`_

Data kind: raw_records_aqmon

(no plugin description)


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>time</td>          <td>int64</td>          <td>Start time since unix epoch [ns]</td>        </tr>        <tr>          <td>length</td>          <td>int32</td>          <td>Length of the interval in samples</td>        </tr>        <tr>          <td>dt</td>          <td>int16</td>          <td>Width of one sample [ns]</td>        </tr>        <tr>          <td>channel</td>          <td>int16</td>          <td>Channel/PMT number</td>        </tr>        <tr>          <td>pulse_length</td>          <td>int32</td>          <td>Length of pulse to which the record belongs (without zero-padding)</td>        </tr>        <tr>          <td>record_i</td>          <td>int16</td>          <td>Fragment number in the pulse</td>        </tr>        <tr>          <td>baseline</td>          <td>int16</td>          <td>Baseline determined by the digitizer (if this is supported)</td>        </tr>        <tr>          <td>data</td>          <td>('&lt;i2', (110,))</td>          <td>Waveform data in raw ADC counts</td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="460pt" height="44pt"
     viewBox="0.00 0.00 460.34 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-40 456.3408,-40 456.3408,4 -4,4"/>
    <!-- raw_records -->
    <g id="node1" class="node">
    <title>raw_records</title>
    <g id="a_node1"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="68.8939" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="68.8939" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- raw_records_aqmon -->
    <g id="node2" class="node">
    <title>raw_records_aqmon</title>
    <g id="a_node2"><a xlink:href="#raw-records-aqmon" xlink:title="raw_records_aqmon">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="260.8939" cy="-18" rx="104.7816" ry="18"/>
    <text text-anchor="middle" x="260.8939" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records_aqmon</text>
    </a>
    </g>
    </g>
    <!-- truth -->
    <g id="node3" class="node">
    <title>truth</title>
    <g id="a_node3"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="417.8939" cy="-18" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="417.8939" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>



truth
--------------------------------------------------------

Description
~~~~~~~~~~~~~~~~~~~~~~

Provided by plugin: `RawRecordsFromFaxNT <https://github.com/XENONnT/wfsim/blob/master/wfsim/strax_interface.py>`_

Data kind: truth

(no plugin description)


Columns provided
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>Field name</th>          <th>Data type</th>          <th>Comment</th>        </tr>      </thead>      <tbody>        <tr>          <td>event_number</td>          <td>int32</td>          <td>Waveform simulator event number.</td>        </tr>        <tr>          <td>type</td>          <td>int8</td>          <td>Quanta type (S1 photons or S2 electrons)</td>        </tr>        <tr>          <td>time</td>          <td>int64</td>          <td>Time of the interaction [ns]</td>        </tr>        <tr>          <td>x</td>          <td>float32</td>          <td>X position of the cluster[cm]</td>        </tr>        <tr>          <td>y</td>          <td>float32</td>          <td>Y position of the cluster[cm]</td>        </tr>        <tr>          <td>z</td>          <td>float32</td>          <td>Z position of the cluster[cm]</td>        </tr>        <tr>          <td>amp</td>          <td>int32</td>          <td>Number of quanta</td>        </tr>        <tr>          <td>recoil</td>          <td>int8</td>          <td>Recoil type of interaction.</td>        </tr>        <tr>          <td>e_dep</td>          <td>float32</td>          <td>Energy deposit of interaction</td>        </tr>        <tr>          <td>g4id</td>          <td>int32</td>          <td>Eventid like in geant4 output rootfile</td>        </tr>        <tr>          <td>vol_id</td>          <td>int32</td>          <td>Volume id giving the detector subvolume</td>        </tr>        <tr>          <td>endtime</td>          <td>int64</td>          <td>End time of the interaction [ns]</td>        </tr>        <tr>          <td>n_electron</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>n_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>n_photon_bottom</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_first_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_last_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_mean_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_sigma_photon</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_first_electron</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_last_electron</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_mean_electron</td>          <td>float64</td>          <td></td>        </tr>        <tr>          <td>t_sigma_electron</td>          <td>float64</td>          <td></td>        </tr>      </tbody>    </table>


Dependencies
~~~~~~~~~~~~~~~~~~~~~~
.. raw:: html

    <!-- Title: %3 Pages: 1 -->
    <svg width="232pt" height="44pt"
     viewBox="0.00 0.00 232.34 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
    <title>%3</title>
    <polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-40 228.3408,-40 228.3408,4 -4,4"/>
    <!-- raw_records -->
    <g id="node1" class="node">
    <title>raw_records</title>
    <g id="a_node1"><a xlink:href="#raw-records" xlink:title="raw_records">
    <ellipse fill="#ff4500" stroke="#000000" cx="68.8939" cy="-18" rx="68.7879" ry="18"/>
    <text text-anchor="middle" x="68.8939" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">raw_records</text>
    </a>
    </g>
    </g>
    <!-- truth -->
    <g id="node2" class="node">
    <title>truth</title>
    <g id="a_node2"><a xlink:href="#truth" xlink:title="truth">
    <ellipse fill="#c0c0c0" stroke="#000000" cx="189.8939" cy="-18" rx="34.394" ry="18"/>
    <text text-anchor="middle" x="189.8939" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">truth</text>
    </a>
    </g>
    </g>
    </g>
    </svg>



Configuration options
~~~~~~~~~~~~~~~~~~~~~~~

These are all options that affect this data type. 
This also includes options taken by dependencies of this datatype,
because changing any of those options affect this data indirectly.

.. raw:: html

    <table border="1" class="dataframe">      <thead>        <tr style="text-align: right;">          <th>option</th>          <th>default</th>          <th>current</th>          <th>applies_to</th>          <th>help</th>        </tr>      </thead>      <tbody>        <tr>          <td>channel_map</td>          <td>&lt;OMITTED&gt;</td>          <td>(tpc, he, aqmon, aqmon_nv, tpc_blank, mv, aux_mv, mv_blank, nveto, nveto_blank)</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>immutabledict mapping subdetector to (min, max) channel number. Provided by context</td>        </tr>        <tr>          <td>chunk_size</td>          <td>100</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Duration of each chunk in seconds</td>        </tr>        <tr>          <td>detector</td>          <td>XENONnT</td>          <td>XENONnT</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>event_rate</td>          <td>1000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Average number of events per second</td>        </tr>        <tr>          <td>fax_config</td>          <td>fax_config_nt_design.json</td>          <td>fax_config_nt_low_field.json</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>fax_config_override</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Dictionary with configuration option overrides</td>        </tr>        <tr>          <td>fax_file</td>          <td>None</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Directory with fax instructions</td>        </tr>        <tr>          <td>gain_model</td>          <td>(to_pe_per_run, https://github.com/XENONnT/private_nt_aux_files/blob/master/sim_files/to_pe_nt.npy?raw=true)</td>          <td>(CMT_model, (to_pe_model, ONLINE))</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>PMT gain model. Specify as (model_type, model_config).</td>        </tr>        <tr>          <td>n_top_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>253</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in top array. Provided by context</td>        </tr>        <tr>          <td>n_tpc_pmts</td>          <td>&lt;OMITTED&gt;</td>          <td>494</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of pmts in tpc. Provided by context</td>        </tr>        <tr>          <td>nchunk</td>          <td>10</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Number of chunks to simulate</td>        </tr>        <tr>          <td>neutron_veto</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for nVeto optical simulation instead of TPC</td>        </tr>        <tr>          <td>optical</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Flag for using optical mc for instructions</td>        </tr>        <tr>          <td>right_raw_extension</td>          <td>50000</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td></td>        </tr>        <tr>          <td>seed</td>          <td>False</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Option for setting the seed of the random number generator used forgeneration of the instructions</td>        </tr>        <tr>          <td>timeout</td>          <td>1800</td>          <td>&lt;OMITTED&gt;</td>          <td>(raw_records, raw_records_he, raw_records_aqmon, truth)</td>          <td>Terminate processing if any one mailbox receives no result for more than this many seconds</td>        </tr>      </tbody>    </table>


